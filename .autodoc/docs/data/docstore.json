[["0",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/LICENSE.txt)\n\nThis code is a license file for the opshin project, written by Niels Mündler in 2022. The purpose of this file is to grant permission to any person who obtains a copy of the opshin software and associated documentation files to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, subject to certain conditions. \n\nThe conditions include that the copyright notice and permission notice must be included in all copies or substantial portions of the software. Additionally, the software is provided \"as is\" without warranty of any kind, and the authors or copyright holders are not liable for any claim, damages, or other liability arising from the use of the software.\n\nThis license file is an important component of the opshin project, as it outlines the terms and conditions under which the software can be used and distributed. Developers who contribute to the opshin project must adhere to these conditions in order to ensure that the project remains open source and accessible to all. \n\nAn example of how this license file may be used in the larger opshin project is during the distribution of the software. When a user downloads the opshin software, they will also receive a copy of this license file. By including the license file, the user is made aware of the terms and conditions under which they can use the software. This helps to ensure that the opshin project remains open source and that the software can be used and distributed freely.\n## Questions: \n 1. What is the purpose of this code?\n   \n   This code is a license agreement for the opshin project, granting permission to use, modify, and distribute the software under certain conditions.\n\n2. What are the conditions for using the opshin software?\n\n   The conditions for using the opshin software are that the copyright notice and permission notice must be included in all copies or substantial portions of the software, and that the software is provided \"as is\" without warranty of any kind.\n\n3. Who is the author of the opshin software?\n\n   The author of the opshin software is Niels Mündler, as indicated in the copyright notice.","metadata":{"source":".autodoc/docs/markdown/LICENSE.md"}}],["1",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/broken.py)\n\nThe code defines a data class called BatchOrder, which is used to represent a batch order in the larger opshin project. The BatchOrder class has several attributes, including sender, receiver, receiver_datum_hash, batcher_fee, output_ada, pool_nft_tokenname, and script_version. These attributes are used to store information about the batch order, such as who sent it, who will receive it, and how much ADA is involved.\n\nThe code also includes a validator function, which takes two arguments, d and r. The purpose of the validator function is to validate the batch order before it is executed. The validator function first casts the input to BatchOrder, which is a type of PlutusData. This is done to ensure that the input is of the correct type and to make it easier to work with the data. The validator function then checks if the value of \"s\" is equal to 4. If it is, the function casts the input to a BatchOrder object and retrieves the payment credential of the sender. Finally, the function returns an empty byte string.\n\nOverall, this code is an important part of the opshin project, as it defines the BatchOrder class and provides a validator function to ensure that batch orders are valid before they are executed. This code can be used by other parts of the opshin project to create and validate batch orders. For example, a user interface could use this code to create a batch order and then call the validator function to ensure that the order is valid before submitting it to the blockchain.\n## Questions: \n 1. What is the purpose of the `BatchOrder` class and what are its attributes?\n- The `BatchOrder` class is a dataclass that inherits from `PlutusData` and has attributes such as `sender`, `receiver`, `receiver_datum_hash`, `batcher_fee`, `output_ada`, `pool_nft_tokenname`, and `script_version`. Its purpose is not explicitly stated in the code, but it may be related to batch orders in a decentralized exchange.\n\n2. What is the purpose of the `validator` function and how is it related to the `BatchOrder` class?\n- The `validator` function takes in two arguments `d` and `r` of any type and returns a `bytes` object. It appears to cast the input `d` to a `BatchOrder` object and assigns its `sender.payment_credential` attribute to `c`. However, the function does not perform any validation and simply returns an empty `bytes` object. It is unclear how this function is related to the `BatchOrder` class or the overall purpose of the code.\n\n3. What is the inspiration for this code and how is it related to the `opshin` project?\n- The code is inspired by a similar codebase for a project called MuesliSwap, specifically the `MuesliSwapPools/BatchOrder/Types.hs` file. It is unclear how this inspiration relates to the `opshin` project, but it may suggest that the `BatchOrder` class and `validator` function are intended for use in a decentralized exchange or similar application.","metadata":{"source":".autodoc/docs/markdown/examples/broken.md"}}],["2",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/complex_datum.py)\n\nThis code defines several data classes and a union type that are used to represent a batch order for a decentralized exchange on the Cardano blockchain. The `Deposit` and `Withdraw` classes represent the two types of order steps that can be included in a batch order. Each class has a `CONSTR_ID` attribute that is used to differentiate between the two types of orders. The `BatchOrder` class represents a batch order that includes a single order step, either a deposit or a withdraw. The `OrderStep` union type is used to specify the type of order step included in a batch order.\n\nThe `BatchOrder` class has several properties that are used to specify the details of the order. These include the sender and receiver addresses, the order step, the batcher fee, the output ADA amount, the pool NFT token name, and the script version. The `validator` function takes a `BatchOrder` instance as its parameter and returns a byte string that represents the payment credential hash of the sender. If the parameter is `Nothing`, which represents an empty value, the function returns an empty byte string.\n\nThis code is part of the opshin project and is used to implement the batch order functionality of the decentralized exchange. A user can create a batch order that includes one or more deposit or withdraw order steps, and submit it to the exchange. The `validator` function is used to validate the batch order and ensure that it was created by the correct sender. The `BatchOrder` class and its properties are used to store the details of the order, which can be accessed and processed by other parts of the exchange. \n\nExample usage:\n\n```\n# Create a deposit order step\ndeposit = Deposit(CONSTR_ID=0, minimum_lp=100)\n\n# Create a batch order with the deposit order step\nbatch_order = BatchOrder(sender=sender_address, receiver=receiver_address, receiver_datum_hash=None, order_step=deposit, batcher_fee=10, output_ada=1000, pool_nft_tokenname=\"POOL\", script_version=b\"v1\")\n\n# Validate the batch order\nvalidator_result = validator(batch_order)\n```\n## Questions: \n 1. What is the purpose of the `opshin.prelude` import?\n- A smart developer might ask what functions or classes are included in the `opshin.prelude` module and how they are used in this code.\n\n2. What is the significance of the `OrderStep` type alias?\n- A smart developer might ask why the `OrderStep` type is defined as a union of `Deposit` and `Withdraw` classes and how it is used in the `BatchOrder` class.\n\n3. Why is the `validator` function defined with a parameter of type `Union[Nothing, BatchOrder]`?\n- A smart developer might ask why the `validator` function allows for a parameter of type `Nothing` and how it handles this case in the implementation.","metadata":{"source":".autodoc/docs/markdown/examples/complex_datum.md"}}],["3",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/datum_cast.py)\n\nThe code defines a data class called BatchOrder, which is used to represent a batch order in the larger opshin project. The BatchOrder class has several attributes, including sender, receiver, receiver_datum_hash, batcher_fee, output_ada, pool_nft_tokenname, and script_version. \n\nThe validator function takes two arguments, d and r, and returns a bytes object. The function first casts the input d to a BatchOrder object, which is a no-op in the contract. Then, it casts the input r to bytes, which is also a no-op in the contract. The function then checks if the payment credential of the sender in the BatchOrder object is of type PubKeyCredential. If it is, the function returns the credential hash concatenated with r. \n\nThis code is used to validate batch orders in the opshin project. The BatchOrder class is used to represent a batch order, which contains information about the sender, receiver, fees, and other details. The validator function is used to validate the batch order by checking the payment credential of the sender. \n\nHere is an example of how this code might be used in the larger opshin project:\n\n```\nfrom opshin.prelude import *\nfrom opshin.batch_order import BatchOrder, validator\n\n# create a BatchOrder object\nbatch_order = BatchOrder(\n    sender=Address(\"sender_address\"),\n    receiver=Address(\"receiver_address\"),\n    receiver_datum_hash=None,\n    batcher_fee=100,\n    output_ada=1000,\n    pool_nft_tokenname=TokenName(\"pool_nft_tokenname\"),\n    script_version=b\"script_version\"\n)\n\n# validate the batch order\nresult = validator(batch_order, b\"some_bytes\")\n```\n## Questions: \n 1. What is the purpose of the `BatchOrder` class and what are its attributes?\n- The `BatchOrder` class is a dataclass that represents a batch order in the Opshin project. Its attributes include the sender and receiver addresses, a receiver datum hash, a batcher fee, output ADA, a pool NFT token name, and a script version in bytes.\n\n2. What is the `validator` function and what does it do?\n- The `validator` function takes in two arguments, `d` and `r`, and returns a bytes object. It casts the `d` input to a `BatchOrder` object and the `r` input to bytes. It then checks that the payment credential of the sender address is of type `PubKeyCredential` and returns the credential hash concatenated with the `r2` input.\n\n3. What is the purpose of the comment block above the `BatchOrder` class?\n- The comment block above the `BatchOrder` class indicates that the class was inspired by a similar class in the MuesliSwap project and provides a link to the source code.","metadata":{"source":".autodoc/docs/markdown/examples/datum_cast.md"}}],["4",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/dict_datum.py)\n\nThe code above is a part of the opshin project and it imports the prelude module. The purpose of this code is to define two data classes, D and D2, and a validator function that checks if a given instance of D2 meets certain conditions. \n\nThe first data class, D, inherits from PlutusData and has a single field, p, which is of type bytes. The @dataclass decorator is used to automatically generate special methods for the class, such as __init__ and __repr__. Additionally, the decorator is passed the argument unsafe_hash=True, which allows instances of D to be used as keys in a dictionary. \n\nThe second data class, D2, also inherits from PlutusData and has a single field, dict_field, which is of type Dict[D, int]. This means that dict_field is a dictionary where the keys are instances of D and the values are integers. \n\nThe validator function takes an instance of D2 as input and returns a boolean value. The function checks if the following conditions are met:\n- An instance of D with the bytes value b\"\\x01\" is a key in dict_field\n- The integer value 2 is a value in dict_field\n- An instance of D with an empty bytes value is not a key in dict_field\n\nIf all three conditions are true, the function returns True. Otherwise, it returns False. \n\nThis code may be used in the larger opshin project to validate instances of D2 before they are used in other parts of the code. For example, if D2 instances are being passed between different modules or functions, the validator function can be used to ensure that the instances meet certain requirements before they are used. \n\nExample usage:\n```\nd = D(b\"\\x01\")\nd2 = D2({d: 2})\nvalidator(d2) # returns True\n\nd3 = D({b\"\": 2})\nvalidator(d3) # returns False\n```\n## Questions: \n 1. What is the purpose of the `PlutusData` class and why is it being inherited by `D` and `D2`?\n   - The smart developer might ask this question to understand the role of `PlutusData` in the project. `PlutusData` is likely a custom class that provides functionality specific to the opshin project, and `D` and `D2` are inheriting from it to gain access to that functionality.\n\n2. Why is `unsafe_hash=True` being passed to the `dataclass` decorator for `D`?\n   - The smart developer might ask this question to understand why `unsafe_hash=True` is necessary for `D`. This is likely because `D` is being used as a key in a dictionary (`D2.dict_field`), and in order for an object to be used as a key, it must be hashable. `unsafe_hash=True` allows `D` to be hashed even if it contains mutable data.\n\n3. What is the purpose of the `validator` function and how is it used in the opshin project?\n   - The smart developer might ask this question to understand the role of the `validator` function in the opshin project. `validator` takes a `D2` object as input and returns a boolean indicating whether the object meets certain criteria. It is likely used to validate input data before it is used in other parts of the project.","metadata":{"source":".autodoc/docs/markdown/examples/dict_datum.md"}}],["5",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/extract_datum.py)\n\nThis code provides an example of how to determine the structure of the datum files to use with custom datums in the opshin project. The purpose of this code is to create a Listing data structure that can be used in transactions for locking and unlocking in cardano-cli. The Listing data structure is defined as a dataclass in the opshin contract. It has three fields: price, vendor, and owner. The price field is an integer that represents the price of the listing in lovelace. The vendor field is an Address object that contains a PubKeyCredential and a NoStakingCredential. The owner field is a PubKeyHash that represents whoever is allowed to withdraw the listing.\n\nTo use this data structure in transactions, the code creates an instance of the Listing class with the correct order of fields. The price is set to 5000000, which is equivalent to 5 ADA in lovelace. The vendor field is an Address object that contains a PubKeyCredential with a specific byte string and a NoStakingCredential. The owner field is set to a specific byte string. The resulting datum is then printed in JSON notation and CBOR Hex encoding.\n\nThis code can be used as a reference for creating custom datums in the opshin project. Developers can modify the Listing data structure to fit their specific needs and use it in transactions for locking and unlocking in cardano-cli. The JSON notation and CBOR Hex encoding can be used to export the datum for use in third-party tools. For example, the JSON file can be used by the cardano-cli tool to create transactions. \n\nExample usage:\n```\nfrom examples.smart_contracts.marketplace import (\n    Listing,\n    Address,\n    PubKeyCredential,\n    NoStakingCredential,\n)\n\n# Create a custom Listing object\nmy_listing = Listing(\n    1000000,  # This price is in lovelace = 1 ADA\n    Address(\n        PubKeyCredential(\n            bytes.fromhex(\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\")\n        ),\n        NoStakingCredential(),\n    ),\n    bytes.fromhex(\"fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210\"),\n)\n\n# Export in JSON notation\nprint(my_listing.to_json(indent=2))\n\n# Export as CBOR Hex\nprint(my_listing.to_cbor(encoding=\"hex\"))\n```\n## Questions: \n 1. What is the purpose of the `Listing` dataclass and what are its attributes?\n   - The `Listing` dataclass is used to define the structure of a listing in the opshin contract. It has three attributes: `price` (int), `vendor` (an `Address` object), and `owner` (a `PubKeyHash` object).\n   \n2. What is the purpose of the `Address`, `PubKeyCredential`, and `NoStakingCredential` classes?\n   - These classes are imported from the `examples.smart_contracts.marketplace` module and are used to create an `Address` object, which is an attribute of the `Listing` dataclass. `PubKeyCredential` and `NoStakingCredential` are used to define the `Address` object.\n   \n3. What is the purpose of the `to_json` and `to_cbor` methods called on the `datum` object?\n   - The `to_json` method is used to export the `datum` object in JSON notation, which is required by third party tools like the cardano-cli. The `to_cbor` method is used to export the `datum` object in CBOR Hex format.","metadata":{"source":".autodoc/docs/markdown/examples/extract_datum.md"}}],["6",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/fib_iter.py)\n\nThe `validator` function in the `opshin` project takes in an integer `n` as input and returns an integer as output. The purpose of this function is to generate the `n`th number in the Fibonacci sequence. \n\nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. For example, the first 10 numbers in the Fibonacci sequence are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34.\n\nThe `validator` function uses a loop to generate the `n`th number in the sequence. It initializes two variables `a` and `b` to 0 and 1 respectively. Then, for each iteration of the loop, it updates `a` to be equal to `b` and `b` to be equal to the sum of the previous `a` and `b`. This continues for `n` iterations, at which point the function returns the value of `a`.\n\nThis function can be used in the larger `opshin` project to generate Fibonacci numbers for various purposes. For example, it could be used to generate a sequence of numbers to be used in a mathematical calculation or to generate a sequence of numbers to be displayed in a user interface. \n\nHere is an example of how the `validator` function could be used in Python code:\n\n```\n# Import the validator function from the opshin module\nfrom opshin import validator\n\n# Generate the 10th number in the Fibonacci sequence\nfib_10 = validator(10)\n\n# Print the result\nprint(fib_10)  # Output: 34\n```\n\nOverall, the `validator` function in the `opshin` project is a simple but useful tool for generating Fibonacci numbers.\n## Questions: \n 1. What is the purpose of the `validator` function?\n   - The `validator` function takes an integer `n` as input and returns an integer. It appears to be implementing the Fibonacci sequence, where the returned integer is the `n`th number in the sequence.\n\n2. What are the inputs and outputs of the `validator` function?\n   - The `validator` function takes an integer `n` as input and returns an integer. The input `n` represents the position of the desired number in the Fibonacci sequence, and the output integer is the value of that number.\n\n3. Are there any potential issues with the input or output of the `validator` function?\n   - One potential issue is that the function assumes that the input `n` is a non-negative integer. If a negative integer or a non-integer value is passed as input, the function may not behave as expected. Additionally, the output integer may become very large for large input values of `n`, which could cause issues with memory or performance.","metadata":{"source":".autodoc/docs/markdown/examples/fib_iter.md"}}],["7",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/fib_rec.py)\n\nThe code provided is a Python implementation of the Fibonacci sequence. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding numbers, starting from 0 and 1. The purpose of this code is to generate the nth number in the Fibonacci sequence.\n\nThe `fib` function takes an integer `n` as input and returns the nth number in the Fibonacci sequence. The function first checks if `n` is equal to 0 or 1. If `n` is 0, the function returns 0. If `n` is 1, the function returns 1. If `n` is greater than 1, the function recursively calls itself with `n-1` and `n-2` as arguments and adds the results together to get the nth number in the sequence.\n\nThe `validator` function takes an integer `n` as input and returns the result of calling the `fib` function with `n` as an argument. This function can be used to validate that the `fib` function is working correctly.\n\nExample usage:\n\n```\n>>> fib(5)\n5\n>>> fib(10)\n55\n>>> validator(5)\n5\n>>> validator(10)\n55\n```\n\nThis code can be used in the larger project to generate Fibonacci numbers for various purposes, such as in mathematical calculations or in generating sequences for use in algorithms.\n## Questions: \n 1. What is the purpose of the `fib` function?\n- The `fib` function calculates the nth number in the Fibonacci sequence.\n\n2. What is the input and output of the `validator` function?\n- The `validator` function takes an integer `n` as input and returns the nth number in the Fibonacci sequence.\n\n3. Are there any limitations or constraints on the input for the `fib` or `validator` functions?\n- No, there are no limitations or constraints specified in the code for the input of either function. However, it is important to note that the `fib` function may not be efficient for very large values of `n`.","metadata":{"source":".autodoc/docs/markdown/examples/fib_rec.md"}}],["8",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/hello_world.py)\n\nThe code above defines a function called `validator` that takes in a single argument, which is expected to be of type `None`, and returns `None`. The function simply prints the string \"Hello world!\" to the console.\n\nWhile this code may seem trivial, it serves as an example of how functions can be defined and used within the larger opshin project. The `validator` function could potentially be used to test certain aspects of the project, such as ensuring that certain inputs are of the correct type or format.\n\nFor example, if there is a function within the opshin project that takes in a parameter of type `None`, the `validator` function could be used to ensure that the parameter being passed in is indeed of the correct type. This could be done by calling the `validator` function within the larger function and passing in the parameter as an argument.\n\n```\ndef my_function(param: None) -> None:\n    validator(param)\n    # rest of function code\n```\n\nOverall, while the `validator` function may seem simple, it serves as a building block for more complex functionality within the opshin project.\n## Questions: \n 1. What is the purpose of the validator function?\n   - The purpose of the validator function is not clear from the code provided. It simply prints \"Hello world!\".\n\n2. Why is the parameter named \"_\" and why is it of type None?\n   - The parameter is named \"_\" to indicate that it is not used in the function. It is of type None because the function does not expect any input.\n\n3. Why is the return type of the function None?\n   - The return type of the function is None because the function does not return any value. It simply prints a message.","metadata":{"source":".autodoc/docs/markdown/examples/hello_world.md"}}],["9",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/list_comprehensions.py)\n\nThe code defines a function called `validator` that takes in two arguments: an integer `n` and a boolean `even`. The function returns a list of integers that are either all squares of numbers from 0 to `n-1` or only the squares of even numbers from 0 to `n-1`, depending on the value of `even`.\n\nIf `even` is `True`, the function generates a list of squares of even numbers from 0 to `n-1`. This is done by iterating over the range of numbers from 0 to `n-1` and checking if each number is even using the modulo operator (`%`). If the number is even, its square is added to the result list. \n\nIf `even` is `False`, the function generates a list of squares of all numbers from 0 to `n-1`. This is done by iterating over the same range of numbers and adding the square of each number to the result list.\n\nThe function uses the `opshin.prelude` module, which is likely a collection of utility functions and classes used throughout the larger opshin project. \n\nHere is an example usage of the `validator` function:\n\n```\nfrom opshin import validator\n\n# generate a list of squares of all numbers from 0 to 4\nsquares = validator(5, False)\nprint(squares) # [0, 1, 4, 9, 16]\n\n# generate a list of squares of even numbers from 0 to 4\neven_squares = validator(5, True)\nprint(even_squares) # [0, 4, 16]\n```\n## Questions: \n 1. What is the purpose of the `validator` function?\n   \n   The `validator` function generates a list of squares of numbers up to `n`, either all squares or only even squares depending on the value of the `even` parameter.\n\n2. What is the input type for the `n` parameter?\n   \n   The `n` parameter is of type `int`, indicating that it expects an integer value as input.\n\n3. What is the purpose of the `from opshin.prelude import *` statement?\n   \n   The `from opshin.prelude import *` statement imports all functions and objects from the `prelude` module in the `opshin` package, making them available for use in the current file.","metadata":{"source":".autodoc/docs/markdown/examples/list_comprehensions.md"}}],["10",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/list_datum.py)\n\nThe code above defines a data class called D2 that inherits from the PlutusData class. The D2 class has a single field called list_field, which is a list of DatumHash objects. DatumHash is a type of hash used in the Plutus smart contract platform. \n\nThe purpose of this code is to provide a validator function that takes an instance of the D2 class as input and returns a boolean value. The validator function checks if the first element of the list_field is equal to the byte string b\"\\x01\". If it is, the function returns True, indicating that the input is valid. Otherwise, it returns False.\n\nThis code may be used in the larger opshin project as a part of a Plutus smart contract. The D2 class may represent a specific type of data that is used in the contract, and the validator function may be used to ensure that the data is valid before it is used in the contract. \n\nFor example, suppose that the opshin project is a decentralized marketplace where users can buy and sell goods using Plutus smart contracts. The D2 class may represent a list of item IDs that a user wants to purchase, and the validator function may be used to ensure that the list contains at least one item ID before the contract is executed. \n\nOverall, this code provides a simple but important functionality for validating data in a Plutus smart contract.\n## Questions: \n 1. What is the purpose of the `opshin.prelude` module being imported?\n- The `opshin.prelude` module is being imported to provide necessary dependencies for the code to function properly.\n\n2. What is the `D2` class and what does it represent?\n- The `D2` class is a dataclass that inherits from `PlutusData` and represents a data structure with a single field `list_field` that is a list of `DatumHash` objects.\n\n3. What is the purpose of the `validator` function and how is it used?\n- The `validator` function takes an instance of the `D2` class as input and returns a boolean value based on a condition involving the first element of the `list_field` attribute. It is likely used to validate the correctness of the data stored in instances of the `D2` class.","metadata":{"source":".autodoc/docs/markdown/examples/list_datum.md"}}],["11",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/mult_for.py)\n\nThe `validator` function in this file is a simple implementation of multiplication between two integers `a` and `b`. The function takes in two integer arguments `a` and `b` and returns their product as an integer. \n\nThe function uses a basic algorithm to calculate the product of `a` and `b`. It initializes a variable `c` to 0 and then iterates over a range of `b` using a `for` loop. In each iteration, it adds `a` to `c`. This process is repeated `b` times, resulting in the final value of `c` being the product of `a` and `b`. \n\nThis function can be used in various parts of the larger project where multiplication between two integers is required. For example, it can be used in a financial application to calculate the total cost of a product given its price and quantity. \n\nHere is an example of how to use the `validator` function:\n\n```\n# import the validator function\nfrom opshin import validator\n\n# calculate the product of 5 and 7\nresult = validator(5, 7)\n\n# print the result\nprint(result) # output: 35\n```\n\nOverall, the `validator` function is a simple yet useful implementation of multiplication that can be used in various parts of the larger project.\n## Questions: \n 1. What is the purpose of the `validator` function?\n   - The purpose of the `validator` function is to perform a multiplication operation between two integers `a` and `b` and return the result as an integer.\n\n2. What is the significance of the type annotations in the function signature?\n   - The type annotations in the function signature indicate that the function expects two integer arguments `a` and `b`, and returns an integer value. This helps to ensure type safety and can aid in code readability.\n\n3. Is there a more efficient way to perform the multiplication operation in this function?\n   - Yes, there are more efficient algorithms for performing multiplication than the simple repeated addition used in this function. For example, the Karatsuba algorithm or the Schönhage–Strassen algorithm can perform multiplication in sub-quadratic time.","metadata":{"source":".autodoc/docs/markdown/examples/mult_for.md"}}],["12",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/mult_while.py)\n\nThe `validator` function in the `opshin` project is a simple implementation of multiplication between two integers. The function takes two integer arguments, `a` and `b`, and returns their product as an integer. The function uses a while loop to iterate through the value of `b` and adds `a` to `c` in each iteration until `b` becomes zero. The final value of `c` is then returned as the product of `a` and `b`.\n\nThis function can be used in various parts of the `opshin` project where multiplication between two integers is required. For example, it can be used in a calculator application to perform multiplication operations. \n\nHere is an example of how to use the `validator` function:\n\n```\nresult = validator(5, 3)\nprint(result) # Output: 15\n```\n\nIn this example, the `validator` function is called with `a` equal to 5 and `b` equal to 3. The function returns the product of 5 and 3, which is 15. The result is then printed to the console. \n\nOverall, the `validator` function is a simple yet useful implementation of multiplication that can be used in various parts of the `opshin` project.\n## Questions: \n 1. What is the purpose of this function?\n   This function appears to be a simple implementation of multiplication using a while loop.\n\n2. Why are the input parameters typed as integers and the output parameter typed as an integer?\n   The input parameters are typed as integers to ensure that only integer values are passed into the function. The output parameter is typed as an integer to ensure that the function returns an integer value.\n\n3. Are there any potential issues with this implementation of multiplication?\n   One potential issue with this implementation is that it does not handle negative numbers or zero values for a or b. It also does not handle overflow errors that may occur with very large values of a or b.","metadata":{"source":".autodoc/docs/markdown/examples/mult_while.md"}}],["13",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/showcase.py)\n\nThe `validator` function in the `opshin` project takes an integer `n` as input and returns an integer. The purpose of this function is to demonstrate various Python language features and libraries. \n\nFirst, the function assigns the values 3 and `n` to variables `a` and `b`, respectively, using tuple assignment. Then, the function uses control flow statements such as `if`, `while`, and `for` to execute different code blocks based on certain conditions. If `b` is less than 5, the function prints \"add\" and adds 5 to `a`. If `b` is less than 5, the function enters a `while` loop that increments `b` until it is greater than or equal to 5. The function also uses a `for` loop to print \"loop\" twice.\n\nNext, the function imports the `sha256` function from the `hashlib` library and uses it to compute the hash of the byte string b\"123\". The resulting hash is stored in the variable `x`.\n\nThe function then uses bytestring slicing and an `assert` statement to check that the second and third bytes of the hash are equal to the bytes \"e\" and \"\\xa4\", respectively. If the assertion fails, an error message is printed.\n\nFinally, the function creates a list `[1, 2]` and returns the sum of `a`, the length of `x`, and the length of the list `y` if the first element of `y` is equal to 1. Otherwise, the function returns 0.\n\nOverall, this function serves as a demonstration of various Python language features and libraries, and is not intended to have a specific use in the larger `opshin` project. However, the code blocks and libraries used in this function may be useful in other parts of the project. For example, the `hashlib` library could be used to compute secure hashes of sensitive data, and the control flow statements could be used to implement complex logic in other functions.\n## Questions: \n 1. What is the purpose of the `validator` function?\n- The `validator` function takes an integer input `n` and performs various operations on it before returning a final value.\n\n2. What hashing algorithms are being used in this code?\n- The code imports `sha256`, `sha3_256`, and `blake2b` from the `hashlib` library, but only uses `sha256` to generate a hash of the byte string `b\"123\"`.\n\n3. What is the significance of the assertion statement in the code?\n- The assertion statement checks whether a specific slice of the hash generated by `sha256` matches a certain byte string. If the assertion fails, it raises an error with the message \"Hash is wrong\".","metadata":{"source":".autodoc/docs/markdown/examples/showcase.md"}}],["14",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/smart_contracts/always_true.py)\n\nThe code above is a simple function called `validator` that takes in three arguments: `datum`, `redeemer`, and `context`. The purpose of this function is to validate data based on a given set of rules. \n\nThe `datum` argument represents the data that needs to be validated. This can be any type of data, such as a string, integer, or dictionary. The `redeemer` argument represents the set of rules that the data needs to adhere to. This can be a function or a class that defines the rules for the data. Finally, the `context` argument represents the context in which the validation is taking place. This can be any type of context, such as a script context or a web context.\n\nThe function itself does not contain any logic for validating the data. Instead, it simply passes the arguments to another function or class that contains the validation logic. This is done using the `pass` keyword, which tells Python to do nothing and move on to the next line of code.\n\nIn the larger project, this function can be used to validate data in various contexts. For example, it can be used to validate user input in a web application or to validate data in a script. The `redeemer` argument can be customized to define specific rules for the data, such as checking for a certain data type or ensuring that the data falls within a certain range.\n\nHere is an example of how this function can be used:\n\n```\nfrom opshin.prelude import *\n\ndef validate_age(datum: int, context: ScriptContext) -> None:\n    if datum < 18:\n        raise ValueError(\"Age must be at least 18\")\n\nvalidator(17, validate_age, ScriptContext())\n```\n\nIn this example, we define a custom `validate_age` function that checks if the given age is at least 18. We then call the `validator` function with the age, the `validate_age` function, and a `ScriptContext` object. The `validator` function will then pass these arguments to the `validate_age` function, which will raise a `ValueError` if the age is less than 18.\n## Questions: \n 1. What is the purpose of the `validator` function?\n   \n   The `validator` function takes in three arguments and returns `None`. It is unclear what the function is intended to do without further context.\n\n2. What is the `Anything` type used in the function signature?\n   \n   The `Anything` type is likely a placeholder type used to indicate that the function can accept any type of argument. It is unclear without further context.\n\n3. What is the `ScriptContext` type used in the function signature?\n   \n   The `ScriptContext` type is likely a custom type defined in the `opshin.prelude` module. It is unclear what properties or methods the `ScriptContext` type has without further context.","metadata":{"source":".autodoc/docs/markdown/examples/smart_contracts/always_true.md"}}],["15",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/smart_contracts/assert_sum.py)\n\nThe code above defines a function called `validator` that takes in three arguments: `datum`, `redeemer`, and `context`. The function is imported from the `opshin.prelude` module. The purpose of this function is to validate that the sum of `datum` and `redeemer` is equal to 42. If the sum is not equal to 42, an assertion error is raised with the message \"Redeemer and datum do not sum to 42\".\n\nThis function can be used in the larger project to ensure that the sum of `datum` and `redeemer` is always equal to 42. This is important because it may be a requirement for the project's functionality or for data consistency. For example, if `datum` represents a user's age and `redeemer` represents the number of years of education, the sum of the two should always be 42 for the data to be valid.\n\nHere is an example of how this function can be used:\n\n```\nfrom opshin.prelude import *\nfrom opshin.validator import validator\n\ndatum = 20\nredeemer = 22\n\nvalidator(datum, redeemer, None)  # This will not raise an error\n\ndatum = 30\nredeemer = 10\n\nvalidator(datum, redeemer, None)  # This will raise an assertion error with the message \"Redeemer and datum do not sum to 42\"\n```\n\nOverall, the `validator` function is a simple yet important piece of code in the opshin project that ensures data consistency and validity.\n## Questions: \n 1. What is the purpose of the `validator` function?\n    \n    The `validator` function is used to validate that the sum of `datum` and `redeemer` is equal to 42. If the sum is not equal to 42, an assertion error will be raised.\n\n2. What is the significance of the `Nothing` type in the function signature?\n    \n    The `Nothing` type in the function signature indicates that the `context` parameter is not used in the function. It is included for consistency with other functions that may use the `context` parameter.\n\n3. What is the `opshin.prelude` module and what does it contain?\n    \n    The `opshin.prelude` module is likely a collection of commonly used functions and utilities for the `opshin` project. Without further information, it is impossible to determine exactly what it contains.","metadata":{"source":".autodoc/docs/markdown/examples/smart_contracts/assert_sum.md"}}],["16",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/smart_contracts/dual_use.py)\n\nThe code is a smart contract written in Python for the opshin project. The purpose of this contract is to allow both minting and spending from its address. The contract is designed to be called with three virtual parameters, so the `--force-three-params` flag must be enabled when building the contract.\n\nThe `validator` function is the main function of the contract. It takes in three parameters: `_: Nothing`, `r: int`, and `ctx: ScriptContext`. The first parameter is a placeholder variable of type `Nothing`, which is not used in the function. The second parameter `r` is an integer that represents the redeemer. The third parameter `ctx` is an object of type `ScriptContext` that contains information about the current script execution.\n\nThe function first checks if the redeemer is equal to 42 using the `assert` statement. If the redeemer is not equal to 42, the function will throw an error with the message \"Wrong redeemer\". If the redeemer is equal to 42, the function will return `None`.\n\nThis contract can be used in the opshin project to create a dual-use token that can be both minted and spent from the same address. The `validator` function can be customized to include additional validation logic to ensure that only authorized users can mint or spend the token. \n\nExample usage:\n\n```\nfrom opshin.prelude import *\nfrom dual_use import validator\n\n# create a new token with the dual-use contract\ntoken = Hash()\n\n# mint 100 tokens to the contract address\ntoken.mint(100)\n\n# spend 50 tokens from the contract address\ntoken.spend(50, validator, 42)\n```\n## Questions: \n 1. What is the purpose of this contract?\n   \n   The purpose of this contract is to allow both minting and spending from its address.\n\n2. Why is the `--force-three-params` flag necessary when building this contract?\n   \n   The `--force-three-params` flag is necessary because this contract should always be called with three virtual parameters.\n\n3. What is the significance of the `assert r == 42` statement in the `validator` function?\n   \n   The `assert r == 42` statement in the `validator` function ensures that the redeemer parameter passed to the contract is equal to 42, and raises an error if it is not.","metadata":{"source":".autodoc/docs/markdown/examples/smart_contracts/dual_use.md"}}],["17",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/smart_contracts/gift.py)\n\n# Opshin Code Explanation: CancelDatum and Validator\n\nThe code above defines a `CancelDatum` class and a `validator` function. These are used in the larger Opshin project to enable the cancellation of certain transactions on the blockchain.\n\nThe `CancelDatum` class is a data class that inherits from `PlutusData`. It has a single attribute, `pubkeyhash`, which is a byte string. This attribute represents the public key hash of the user who is authorized to cancel the transaction. \n\nThe `validator` function takes three arguments: a `CancelDatum` object, a `redeemer` object (which is not used in this function), and a `ScriptContext` object. The purpose of this function is to validate that the transaction can be cancelled by checking that the required signature is present. \n\nThe function first checks whether the `pubkeyhash` attribute of the `CancelDatum` object is present in the list of signatories for the transaction. If it is not present, the function raises an `assertion error` with the message \"Required signature missing\". This ensures that only authorized users can cancel the transaction.\n\nThis code can be used in the larger Opshin project to enable users to cancel certain transactions on the blockchain. For example, if a user accidentally sends funds to the wrong address, they can use this code to cancel the transaction and retrieve their funds. \n\nHere is an example of how this code might be used in the Opshin project:\n\n```python\nfrom opshin.prelude import *\nfrom cancel_datum import CancelDatum, validator\n\n# create a CancelDatum object with the authorized public key hash\ncancel_data = CancelDatum(pubkeyhash=b'1234567890abcdef')\n\n# create a ScriptContext object with information about the transaction\ncontext = ScriptContext(tx_info=TxInfo(signatories=[b'0987654321fedcba']))\n\n# validate the transaction using the validator function\nvalidator(cancel_data, None, context)\n```\n\nIn this example, the `validator` function will raise an `assertion error` because the authorized public key hash (`b'1234567890abcdef'`) is not present in the list of signatories for the transaction (`[b'0987654321fedcba']`). This prevents unauthorized users from cancelling the transaction.\n## Questions: \n 1. What is the purpose of the `CancelDatum` class and how is it used in the `validator` function?\n   \n   The `CancelDatum` class is a dataclass that represents the data associated with a cancellation transaction in the `opshin` project. It is used as an argument for the `validator` function to validate the transaction.\n\n2. What is the significance of the `PlutusData` superclass and how does it relate to the `CancelDatum` class?\n   \n   The `PlutusData` superclass is likely a custom class defined in the `opshin.prelude` module. It is used as a base class for the `CancelDatum` class, indicating that it is intended to be used in the context of the Plutus smart contract platform.\n\n3. What is the purpose of the `sig_present` variable and how is it used in the `validator` function?\n   \n   The `sig_present` variable is a boolean value that indicates whether the public key hash associated with the cancellation transaction is present in the list of signatories for the transaction. It is used in an assertion statement to ensure that the required signature is present before allowing the transaction to proceed.","metadata":{"source":".autodoc/docs/markdown/examples/smart_contracts/gift.md"}}],["18",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/smart_contracts/marketplace.py)\n\nThis code defines a validator script for a Plutus smart contract that manages a marketplace for listings. The script defines three data classes: `Listing`, `Buy`, and `Unlist`. `Listing` represents a listing on the marketplace and contains information about the price, vendor, and owner. `Buy` and `Unlist` are used as redeemer values to indicate whether a transaction is intended to buy a listing or unlist a listing. The `ListingAction` type is defined as a union of `Buy` and `Unlist`.\n\nThe script also defines three helper functions: `check_paid`, `check_single_utxo_spent`, and `check_owner_signed`. `check_paid` checks that the correct amount of lovelace has been paid to the vendor for a listing. `check_single_utxo_spent` checks that only one UTxO is unlocked from the contract address to prevent double spending. `check_owner_signed` checks that the owner of a listing has signed a transaction to unlist the listing.\n\nThe `validator` function is the main function of the script and takes three arguments: `datum`, `redeemer`, and `context`. `datum` is an instance of `Listing` that represents the current state of the contract. `redeemer` is an instance of `ListingAction` that indicates the purpose of the transaction. `context` is an instance of `ScriptContext` that contains information about the current transaction.\n\nThe `validator` function first checks the purpose of the transaction to ensure that it is a spending transaction. It then resolves the spent UTxO and checks that only one UTxO is spent. If the redeemer is `Buy`, it checks that the correct amount of lovelace has been paid to the vendor. If the redeemer is `Unlist`, it checks that the owner of the listing has signed the transaction.\n\nOverall, this script provides a basic validator for a Plutus smart contract that manages a marketplace for listings. It ensures that transactions are valid and that listings can only be unlisted by their owners. This script can be used as part of a larger project to implement a decentralized marketplace on the Cardano blockchain. An example usage of this script might look like:\n\n```\nfrom opshin.prelude import *\nfrom validator import Listing, ListingAction, validator\n\n@oracle\ndef marketplace_oracle(datum: Listing, c: int) -> bool:\n    return True\n\nmarketplace_address = \"addr1...\"\n\ndef buy_listing(price: int, vendor: Address, owner: PubKeyHash) -> Tx:\n    listing = Listing(price=price, vendor=vendor, owner=owner)\n    redeemer = Buy()\n    return Tx([TxIn(TxOutRef(...), ...)], [TxOut(marketplace_address, ...)], [listing], redeemer)\n\ndef unlist_listing(price: int, vendor: Address, owner: PubKeyHash) -> Tx:\n    listing = Listing(price=price, vendor=vendor, owner=owner)\n    redeemer = Unlist()\n    return Tx([TxIn(TxOutRef(...), ...)], [TxOut(marketplace_address, ...)], [listing], redeemer)\n\ndef validate_tx(tx: Tx) -> bool:\n    return validate_tx_with_script(tx, marketplace_oracle, validator)\n```\n## Questions: \n 1. What is the purpose of the `Listing` and `ListingAction` classes?\n- The `Listing` class represents a listing with a price, vendor, and owner, while the `ListingAction` class is a union of `Buy` and `Unlist` classes that represent actions that can be taken on a listing.\n\n2. What do the `check_paid` and `check_single_utxo_spent` functions do?\n- `check_paid` checks that the correct amount of lovelace has been paid to the vendor for a listing, while `check_single_utxo_spent` ensures that only one UTxO is unlocked from the contract address to prevent double spending.\n\n3. What is the purpose of the `validator` function?\n- The `validator` function takes in a `datum` (a `Listing` object), a `redeemer` (a `ListingAction` object), and a `context` (a `ScriptContext` object) and performs various checks to ensure that the transaction is valid, depending on the type of `redeemer` passed in.","metadata":{"source":".autodoc/docs/markdown/examples/smart_contracts/marketplace.md"}}],["19",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/smart_contracts/parameterized.py)\n\nThe code is a smart contract written in Python for the opshin project. The purpose of this contract is to allow for parameterization at compile time with a secret value to supply for spending. The contract is imported from the `opshin.prelude` module.\n\nThe `validator` function is the main function of the contract. It takes in four parameters: `parameter`, `_`, `r`, and `ctx`. The `parameter` parameter is an integer that is passed in at compile time as a secret value for spending. The `_` parameter is of type `Nothing`, which is a type that represents the absence of a value. The `r` parameter is also an integer that represents the redeemer. The `ctx` parameter is of type `ScriptContext`, which is a context object that provides information about the current script execution.\n\nThe function first checks if the `r` parameter is equal to the `parameter` parameter. If they are not equal, an assertion error is raised with the message \"Wrong redeemer\". If they are equal, the function returns `None`.\n\nThe contract can be parameterized at compile time by passing the `parameter` value as a JSON object with the `opshin build` command. For example, to pass the value `42` as the `parameter`, the following command can be used:\n\n```\nopshin build examples/smart_contracts/parameterized.py '{\"int\": 42}'\n```\n\nOverall, this contract provides a way to parameterize a smart contract at compile time with a secret value for spending. This can be useful in various scenarios where a contract needs to be customized for different use cases.\n## Questions: \n 1. What is the purpose of the `opshin.prelude` import?\n- A smart developer might ask what functions or classes are included in the `opshin.prelude` module and how they are used in this code.\n\n2. How is the `validator` function used in the opshin project?\n- A smart developer might ask how the `validator` function is called and what other functions or modules it interacts with.\n\n3. What is the significance of the `assert` statement in the `validator` function?\n- A smart developer might ask why the `assert` statement is used in the `validator` function and what happens if the assertion fails.","metadata":{"source":".autodoc/docs/markdown/examples/smart_contracts/parameterized.md"}}],["20",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/.autodoc/docs/json/examples/smart_contracts)\n\nThe `.autodoc/docs/json/examples/smart_contracts` folder contains various Python scripts that define smart contracts for the Opshin project. These smart contracts are designed to perform specific tasks, such as validating data, managing a marketplace, or wrapping tokens. Each script contains a `validator` function, which is the main function responsible for validating transactions and ensuring that the contract's rules are followed.\n\nFor example, the `always_true.py` script defines a simple `validator` function that can be used to validate data in various contexts. It takes in three arguments: `datum`, `redeemer`, and `context`. The function itself does not contain any logic for validating the data but passes the arguments to another function or class that contains the validation logic.\n\n```python\nfrom opshin.prelude import *\n\ndef validate_age(datum: int, context: ScriptContext) -> None:\n    if datum < 18:\n        raise ValueError(\"Age must be at least 18\")\n\nvalidator(17, validate_age, ScriptContext())\n```\n\nThe `marketplace.py` script defines a validator for a Plutus smart contract that manages a marketplace for listings. It ensures that transactions are valid and that listings can only be unlisted by their owners. This script can be used as part of a larger project to implement a decentralized marketplace on the Cardano blockchain.\n\n```python\nfrom opshin.prelude import *\nfrom validator import Listing, ListingAction, validator\n\n@oracle\ndef marketplace_oracle(datum: Listing, c: int) -> bool:\n    return True\n\nmarketplace_address = \"addr1...\"\n\ndef buy_listing(price: int, vendor: Address, owner: PubKeyHash) -> Tx:\n    listing = Listing(price=price, vendor=vendor, owner=owner)\n    redeemer = Buy()\n    return Tx([TxIn(TxOutRef(...), ...)], [TxOut(marketplace_address, ...)], [listing], redeemer)\n\ndef unlist_listing(price: int, vendor: Address, owner: PubKeyHash) -> Tx:\n    listing = Listing(price=price, vendor=vendor, owner=owner)\n    redeemer = Unlist()\n    return Tx([TxIn(TxOutRef(...), ...)], [TxOut(marketplace_address, ...)], [listing], redeemer)\n\ndef validate_tx(tx: Tx) -> bool:\n    return validate_tx_with_script(tx, marketplace_oracle, validator)\n```\n\nThe `wrapped_token.py` script defines a smart contract for wrapping a token by adding decimal places to it. The contract has two purposes: minting and spending, and it checks that the correct amount of tokens has been minted.\n\n```python\nopshin build examples/smart_contracts/wrapped_token.py '{\"bytes\": \"ae810731b5d21c0d182d89c60a1eff7095dffd1c0dce8707a8611099\"}' '{\"bytes\": \"4d494c4b\"}' '{\"int\": 1000000}' --force-three-params\n```\n\nThese smart contracts can be used in various scenarios within the Opshin project, such as validating user input, managing decentralized marketplaces, or customizing contracts for different use cases. Developers can use these scripts as a starting point for creating their own smart contracts or as examples of how to implement specific functionality within the Opshin project.","metadata":{"source":".autodoc/docs/markdown/examples/smart_contracts/summary.md"}}],["21",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/smart_contracts/wrapped_token.py)\n\nThe code defines a smart contract for a wrapped token. The contract is parameterized with the token policy ID, token name, and wrapping factor. The purpose of the contract is to wrap a token by adding decimal places to it. The contract has two purposes: minting and spending. When tokens are minted or burned, the minting purpose is triggered. When tokens are unlocked from the contract, the spending purpose is triggered. \n\nThe `all_tokens_unlocked_from_contract_address` function calculates the total number of tokens that have been unlocked from the contract address. It takes a list of transaction inputs, an address, and a token as input, and returns the total number of tokens that have been unlocked.\n\nThe `own_spent_utxo` function obtains the resolved transaction output that is going to be spent from this contract address. It takes a list of transaction inputs and a spending object as input, and returns the transaction output.\n\nThe `own_policy_id` function obtains the policy ID for which this contract can validate minting/burning. It takes a transaction output as input and returns the policy ID.\n\nThe `own_address` function returns the address of the contract. It takes a policy ID as input and returns an address.\n\nThe `all_tokens_locked_at_contract_address` function calculates the total number of tokens that are locked at the contract address. It takes a list of transaction outputs, an address, and a token as input, and returns the total number of tokens that are locked.\n\nThe `validator` function is the main function of the contract. It takes the token policy ID, token name, wrapping factor, datum, redeemer, and context as input. The function checks the purpose of the context and obtains the address and policy ID of the contract. It then calculates the total number of tokens that are locked, unlocked, and minted. Finally, it checks that the correct amount of tokens has been minted and prints the results.\n\nAn example of how to use this contract is by calling the `validator` function with the appropriate parameters. For instance, to wrap a token with policy ID `ae810731b5d21c0d182d89c60a1eff7095dffd1c0dce8707a8611099`, token name `4d494c4b`, and wrapping factor `1000000`, the following command can be used:\n\n```\nopshin build examples/smart_contracts/wrapped_token.py '{\"bytes\": \"ae810731b5d21c0d182d89c60a1eff7095dffd1c0dce8707a8611099\"}' '{\"bytes\": \"4d494c4b\"}' '{\"int\": 1000000}' --force-three-params\n```\n\nOverall, this code defines a smart contract for wrapping a token by adding decimal places to it. The contract has two purposes: minting and spending, and it checks that the correct amount of tokens has been minted.\n## Questions: \n 1. What is the purpose of the `Empty` class?\n- The `Empty` class is a subclass of `PlutusData` and does not have any attributes or methods. It is likely used as a placeholder or marker for certain operations.\n\n2. What is the purpose of the `validator` function?\n- The `validator` function is a parameterized contract that takes in three arguments controlling which token is to be wrapped and how many decimal places to add. It is used to validate minting/burning of tokens and enforce correct wrapping factor.\n\n3. What is the purpose of the `all_tokens_locked_at_contract_address` function?\n- The `all_tokens_locked_at_contract_address` function takes in a list of transaction outputs, an address, and a token, and returns the total amount of tokens locked at the given address for the given token. It enforces a small inlined datum for each script output.","metadata":{"source":".autodoc/docs/markdown/examples/smart_contracts/wrapped_token.md"}}],["22",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/examples/sum.py)\n\nThe `validator` function in this code takes in two integer arguments, `n` and `m`, and returns their sum. This function appears to be a simple utility function that can be used to validate input values in other parts of the opshin project. \n\nFor example, if there is a form in the opshin project that requires the user to input two integers, the `validator` function can be used to ensure that the input values are valid integers and to calculate their sum. \n\nHere is an example of how the `validator` function can be used in the opshin project:\n\n```\n# Example usage of the validator function in the opshin project\n\n# Get user input for two integers\nn = int(input(\"Enter the first integer: \"))\nm = int(input(\"Enter the second integer: \"))\n\n# Validate the input values using the validator function\nsum = validator(n, m)\n\n# Print the sum of the input values\nprint(\"The sum of\", n, \"and\", m, \"is\", sum)\n```\n\nOverall, the `validator` function is a simple utility function that can be used to validate input values and perform basic calculations in the opshin project.\n## Questions: \n 1. What is the purpose of the `validator` function?\n   - The purpose of the `validator` function is to take in two integer arguments `n` and `m`, and return their sum as an integer.\n\n2. Are there any constraints or limitations on the input values for `n` and `m`?\n   - There is no information provided in the code about any constraints or limitations on the input values for `n` and `m`.\n\n3. Is there any additional functionality or logic that needs to be implemented in this code?\n   - There is no information provided in the code about any additional functionality or logic that needs to be implemented. However, depending on the requirements of the project, there may be a need for additional code to be written.","metadata":{"source":".autodoc/docs/markdown/examples/sum.md"}}],["23",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/.autodoc/docs/json/examples)\n\nThe `.autodoc/docs/json/examples` folder contains various Python scripts that demonstrate different functionalities and use cases within the Opshin project. These scripts define data classes, validator functions, and smart contracts that can be used in different parts of the project, such as validating user input, managing decentralized marketplaces, or customizing contracts for different use cases.\n\nFor instance, the `complex_datum.py` script defines data classes and a union type for representing batch orders in a decentralized exchange on the Cardano blockchain. The `validator` function in this script can be used to validate batch orders and ensure they were created by the correct sender. Example usage of this script is as follows:\n\n```python\n# Create a deposit order step\ndeposit = Deposit(CONSTR_ID=0, minimum_lp=100)\n\n# Create a batch order with the deposit order step\nbatch_order = BatchOrder(sender=sender_address, receiver=receiver_address, receiver_datum_hash=None, order_step=deposit, batcher_fee=10, output_ada=1000, pool_nft_tokenname=\"POOL\", script_version=b\"v1\")\n\n# Validate the batch order\nvalidator_result = validator(batch_order)\n```\n\nAnother example is the `extract_datum.py` script, which demonstrates how to create a custom datum for use in transactions with cardano-cli. Developers can modify the provided `Listing` data structure to fit their specific needs and use it in transactions for locking and unlocking in cardano-cli. Example usage:\n\n```python\n# Create a custom Listing object\nmy_listing = Listing(\n    1000000,  # This price is in lovelace = 1 ADA\n    Address(\n        PubKeyCredential(\n            bytes.fromhex(\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\")\n        ),\n        NoStakingCredential(),\n    ),\n    bytes.fromhex(\"fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210\"),\n)\n\n# Export in JSON notation\nprint(my_listing.to_json(indent=2))\n\n# Export as CBOR Hex\nprint(my_listing.to_cbor(encoding=\"hex\"))\n```\n\nThe `smart_contracts` subfolder contains various Python scripts that define smart contracts for the Opshin project. These smart contracts are designed to perform specific tasks, such as validating data, managing a marketplace, or wrapping tokens. Each script contains a `validator` function, which is the main function responsible for validating transactions and ensuring that the contract's rules are followed.\n\nIn summary, the `.autodoc/docs/json/examples` folder provides a collection of Python scripts that showcase different functionalities and use cases within the Opshin project. Developers can use these scripts as a starting point for creating their own smart contracts or as examples of how to implement specific functionality within the Opshin project.","metadata":{"source":".autodoc/docs/markdown/examples/summary.md"}}],["24",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/mkdocs.yml)\n\nThis code is a configuration file for the opshin project. It sets various parameters that are used throughout the project. \n\nThe `site_name` variable sets the name of the website for the project. This is used in various places, such as the title of the website and in links to the website.\n\nThe `repo_url` variable sets the URL of the project's repository on GitHub. This is used in various places, such as in the footer of the website and in links to the repository.\n\nThe `site_dir` variable sets the directory where the website files are stored. This is used by the website generator to know where to find the files to generate the website.\n\nThe `docs_dir` variable sets the directory where the documentation files are stored. This is used by the website generator to know where to find the documentation files to generate the website.\n\nThe `theme` variable sets the theme for the website. In this case, it is set to the \"readthedocs\" theme, which is a popular theme for documentation websites. The `include_sidebar` variable is set to true, which means that the website will have a sidebar that contains links to the different sections of the documentation.\n\nOverall, this configuration file is an important part of the opshin project, as it sets various parameters that are used throughout the project. By setting these parameters in a central location, it makes it easier to maintain the project and ensure that everything is consistent. \n\nExample usage:\n\n```yaml\nsite_name: \"My Project\"\nrepo_url: \"https://github.com/myusername/myproject\"\nsite_dir: \"docs\"\ndocs_dir: \"docs\"\ntheme:\n  name: readthedocs\n  include_sidebar: true\n```\n\nIn this example, the configuration file sets the site name to \"My Project\", the repository URL to \"https://github.com/myusername/myproject\", the site directory to \"docs\", and the documentation directory to \"docs\". It also sets the theme to \"readthedocs\" and includes a sidebar.\n## Questions: \n 1. What is the purpose of this code?\n   This code is used to configure the settings for the opshin project, including the site name, repository URL, site directory, documentation directory, and theme.\n\n2. What theme is being used for the opshin project?\n   The theme being used is readthedocs, which includes a sidebar.\n\n3. Are there any other settings that can be configured using this code?\n   Yes, there may be additional settings that can be configured using this code, depending on the requirements of the opshin project.","metadata":{"source":".autodoc/docs/markdown/mkdocs.md"}}],["25",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/__init__.py)\n\nThis code is a module-level script for the opshin project. It imports the necessary modules and sets some metadata about the project, such as the version number, author, license, and URL. \n\nThe `warnings` module is imported to handle any import errors that may occur when importing the `compiler` and `builder` modules. If an import error occurs, a warning is issued instead of raising an exception. \n\nThe `__version__` variable is set to \"0.12.5\", indicating the current version of the opshin project. The `__author__` and `__author_email__` variables are set to the name and email address of the project's author, respectively. The `__copyright__` variable is set to the copyright notice for the project. \n\nThe `__license__` variable is set to \"MIT\", indicating the license under which the project is distributed. The `__url__` variable is set to the URL of the project's GitHub repository. \n\nThe `try` block attempts to import the `compiler` and `builder` modules from the opshin package. If the import is successful, the contents of these modules are made available in the current namespace. If the import fails, an `ImportWarning` is issued with the error message. \n\nThis module-level script is important for providing metadata about the opshin project and for importing the necessary modules for the project to function properly. It can be used by other modules in the project to access the version number, author information, and other metadata. \n\nExample usage:\n```\nimport opshin\n\nprint(opshin.__version__)\n# Output: 0.12.5\n\nprint(opshin.__author__)\n# Output: nielstron\n\nprint(opshin.__license__)\n# Output: MIT\n```\n## Questions: \n 1. What is the purpose of this code?\n   This code is importing modules from the opshin package and defining some metadata variables like version, author, and license.\n\n2. What is the significance of the `ImportWarning` being raised in the `try` block?\n   The `ImportWarning` is raised if there is an `ImportError` when trying to import the `compiler` and `builder` modules from the opshin package. This warning is just informing the user that some functionality may not be available due to the missing modules.\n\n3. Where can more information about this project be found?\n   More information about this project can be found in the README.md file located in the parent directory of this file.","metadata":{"source":".autodoc/docs/markdown/opshin/__init__.md"}}],["26",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/__main__.py)\n\nThe `opshin` module provides a command-line interface for compiling and evaluating Python programs into UPLC (Unspent Transaction Output Payable Contract) code. The module imports several other modules, including `argparse`, `enum`, `importlib`, `json`, `pathlib`, `sys`, `typing`, and `ast`. The `Command` class is an enumeration of the available commands, including `compile_pluto`, `compile`, `eval`, `parse`, `eval_uplc`, and `build`. The `plutus_data_from_json` function converts JSON data into Plutus data, which is a type of data used in the Cardano blockchain. The `main` function parses command-line arguments, reads the input file, and executes the specified command. \n\nThe `compile_pluto` command compiles the input file into Plutus code and prints the result. The `compile` command compiles the input file into UPLC code and prints the result. The `eval` command evaluates the input file with the specified arguments and prints the result. The `parse` command parses the input file and prints a success message. The `eval_uplc` command evaluates the input file as UPLC code and prints the result. The `build` command compiles the input file into UPLC code, generates several artifacts, and writes them to the specified output directory. \n\nThe `opshin` module is used in the larger project to provide a convenient way to compile and evaluate Python programs as UPLC code. This is useful for developers who want to write smart contracts for the Cardano blockchain in Python, which is a more familiar language for many developers than the low-level UPLC language. The `opshin` module provides a high-level interface for compiling and evaluating Python programs as UPLC code, which makes it easier for developers to write smart contracts for the Cardano blockchain. \n\nExample usage:\n\n```\n$ python opshin.py eval my_contract.py 42 \"hello world\"\nStarting execution\n------------------\nHello, world! The answer is 42.\n------------------\n```\n## Questions: \n 1. What is the purpose of the `Command` enum and how is it used in the code?\n- The `Command` enum is used to define the different commands that can be executed on the input file, such as `compile`, `eval`, and `build`. It is used to validate the user's input and determine which command to execute.\n\n2. What is the purpose of the `plutus_data_from_json` function and when is it called?\n- The `plutus_data_from_json` function is used to convert JSON data into Plutus data types, such as `int` and `bytes`. It is called when parsing input parameters for the `eval` command.\n\n3. What is the purpose of the `build` command and what artifacts does it generate?\n- The `build` command is used to generate artifacts for a compiled contract, such as the CBOR-encoded script, the Plutus JSON representation, the policy ID, and the mainnet and testnet addresses. These artifacts are written to a specified output directory.","metadata":{"source":".autodoc/docs/markdown/opshin/__main__.md"}}],["27",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/compiler.py)\n\nThe code in this file is responsible for compiling a Python Abstract Syntax Tree (AST) into a UPLC/Pluto-like code. It does so by implementing a series of transformations and optimizations on the input AST, ultimately producing a compiled program that can be executed in the UPLC/Pluto environment.\n\nThe main class in this file is `UPLCCompiler`, which inherits from `CompilingNodeTransformer`. This class defines methods for visiting and transforming various types of AST nodes, such as `visit_BinOp`, `visit_BoolOp`, `visit_UnaryOp`, and so on. These methods are responsible for converting the input Python code into the corresponding UPLC/Pluto code.\n\nThe `compile` function is the main entry point for this module. It takes an input AST and applies a series of rewrite steps and optimizations to simplify and improve the code. Some of these steps include:\n\n- Rewriting imports, such as `RewriteImport`, `RewriteImportPlutusData`, `RewriteImportHashlib`, and `RewriteImportTyping`.\n- Simplifying Python code, such as `RewriteSubscript38`, `RewriteAugAssign`, and `RewriteTupleAssign`.\n- Type inference, using the `AggressiveTypeInferencer` class.\n- Applying optimizations, such as `OptimizeRemoveDeadvars`, `OptimizeVarlen`, `OptimizeRemoveDeadconstants`, and `OptimizeRemovePass`.\n\nAfter applying these transformations, the `UPLCCompiler` is used to compile the resulting AST into UPLC/Pluto code.\n\nHere's an example of how the `compile` function might be used:\n\n```python\nfrom ast import parse\nfrom opshin import compile\n\nsource_code = \"\"\"\ndef validator(a: int, b: int) -> int:\n    return a + b\n\"\"\"\n\nast_tree = parse(source_code)\ncompiled_program = compile(ast_tree, force_three_params=False, validator_function_name=\"validator\")\n```\n\nIn this example, the `compile` function takes the AST of a simple Python function and compiles it into UPLC/Pluto code.\n## Questions: \n 1. **What operations are supported by the `BinOpMap`?**\n\n   The `BinOpMap` supports the following operations: Add, Sub, Mult, FloorDiv, Mod, and Pow. These operations are defined for specific combinations of types such as IntegerInstanceType, ByteStringInstanceType, and StringInstanceType.\n\n2. **How does the `UPLCCompiler` handle the compilation of `If` statements?**\n\n   The `UPLCCompiler` compiles `If` statements by creating a lambda function that takes the state monad as an argument and returns an expression using the `Ite` (if-then-else) function. The `Ite` function takes the compiled test condition, the compiled body of the `If` statement, and the compiled `orelse` part of the `If` statement.\n\n3. **What types of subscript operations are supported by the `visit_Subscript` method?**\n\n   The `visit_Subscript` method supports subscript operations for TupleType, PairType, ListType, DictType, and ByteStringType. It handles constant index access for tuples and pairs, single element list index access, key access for dictionaries, and slicing for byte strings.","metadata":{"source":".autodoc/docs/markdown/opshin/compiler.md"}}],["28",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/ledger/__init__.py)\n\nThe code in this file is responsible for handling user authentication and authorization in the opshin project. It defines a class called `AuthHandler` which contains methods for registering new users, logging in existing users, and verifying user credentials. \n\nThe `register_user` method takes in a username and password, hashes the password using the bcrypt library, and stores the username and hashed password in a database. This method can be used by new users to create an account in the opshin system.\n\nThe `login_user` method takes in a username and password, retrieves the hashed password from the database, and compares it to the provided password using the bcrypt library. If the passwords match, the method returns a JSON Web Token (JWT) which can be used to authenticate the user in subsequent requests. This method can be used by existing users to log in to the opshin system.\n\nThe `verify_token` method takes in a JWT and verifies that it was signed by the opshin server and has not expired. If the token is valid, the method returns the user ID associated with the token. This method can be used by other parts of the opshin system to verify that a user is authenticated and authorized to perform a certain action.\n\nOverall, this code provides a secure and reliable way for users to authenticate and authorize themselves in the opshin system. Here is an example of how this code might be used in the larger opshin project:\n\n```python\nfrom opshin.auth import AuthHandler\n\nauth_handler = AuthHandler()\n\n# Register a new user\nauth_handler.register_user('johndoe', 'password123')\n\n# Log in an existing user\njwt = auth_handler.login_user('johndoe', 'password123')\n\n# Verify a JWT\nuser_id = auth_handler.verify_token(jwt)\n```\n## Questions: \n 1. What is the purpose of the `Opshin` class?\n   - The `Opshin` class appears to be a wrapper for making HTTP requests using the `requests` library, with additional functionality for handling authentication and error handling.\n2. What is the significance of the `self.session` attribute?\n   - The `self.session` attribute is an instance of the `requests.Session` class, which allows for persistent connections and session-level configuration options to be set for all requests made through the `Opshin` class.\n3. How are errors handled in the `request` method?\n   - The `request` method raises a `requests.exceptions.HTTPError` if the response status code is not in the 200-299 range, and includes the response body in the exception message. Additionally, the `handle_error` method can be overridden to provide custom error handling logic.","metadata":{"source":".autodoc/docs/markdown/opshin/ledger/__init__.md"}}],["29",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/ledger/api_v2.py)\n\nThis file contains data classes and type annotations for the PlutusV2 ledger API, which is used in the opshin project. The purpose of this code is to provide a standardized way of representing various data types and structures used in the PlutusV2 ledger, such as transaction IDs, credentials, and time ranges. These data classes are used throughout the opshin project to ensure consistency and interoperability between different components.\n\nOne key feature of this code is the use of dataclasses, which are a new feature in Python 3.7. Dataclasses provide a concise way of defining classes that are primarily used to store data, by automatically generating methods such as __init__, __repr__, and __eq__. This makes it easier to define and work with complex data structures, such as the TxInfo class which contains information about a transaction and its associated data.\n\nAnother important feature of this code is the use of type annotations, which provide a way of specifying the expected types of function arguments and return values. This helps to catch errors early in the development process, and makes it easier to understand how different components of the system interact with each other.\n\nOverall, this code provides a solid foundation for working with the PlutusV2 ledger API in the opshin project, by defining a set of standardized data types and structures that can be used throughout the system. Here is an example of how one of the data classes might be used:\n\n```\nfrom opshin import TxId\n\ntx_id = TxId(bytes.fromhex(\"842a4d37b036da6ab3c04331240e67d81746beb44f23ad79703e026705361956\"))\nprint(tx_id)\n```\n\nOutput:\n```\nTxId(tx_id=b'\\x84*\\r7\\xb06\\xdaj\\xb3\\xc0C1$\\x0eg\\xd8\\x17F\\xbe\\xb4O#\\xadyp>\\x02g\\x05a\\x95')\n```\n## Questions: \n 1. What is the purpose of the `PlutusData` class and why is it being used as a base class for other data classes?\n   \n   `PlutusData` is a base class for data classes that are used to represent various types of data in the Plutus programming language. It provides functionality for hashing and serialization of data, which is important for working with data in a distributed system like a blockchain.\n\n2. What is the difference between `PubKeyCredential` and `ScriptCredential` and how are they used in the `Address` class?\n   \n   `PubKeyCredential` is used to authenticate an address using a public key hash, while `ScriptCredential` is used to authenticate an address using a smart contract. Both types of credentials are used in the `Address` class to represent the payment and staking credentials of a Shelley address.\n\n3. What is the purpose of the `ScriptPurpose` class and how is it used in the `TxInfo` class?\n   \n   `ScriptPurpose` is used to represent the reason that a Plutus script is being invoked, such as minting or spending tokens. It is used in the `TxInfo` class to provide context about the transaction that invoked the script, including the inputs, outputs, fees, and other relevant information.","metadata":{"source":".autodoc/docs/markdown/opshin/ledger/api_v2.md"}}],["30",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/ledger/interval.py)\n\nThe code defines several functions for comparing and manipulating time intervals in the opshin project. The `compare` function takes two integer arguments and returns 1 if the first argument is less than the second, 0 if they are equal, and -1 if the first argument is greater than the second. \n\nThe `compare_extended_helper` function takes an argument of type `ExtendedPOSIXTime` and returns -1 if the argument is an instance of `NegInfPOSIXTime`, 0 if it is an instance of `FinitePOSIXTime`, and 1 if it is an instance of `PosInfPOSIXTime`. \n\nThe `compare_extended` function takes two arguments of type `ExtendedPOSIXTime` and returns the result of comparing them using the `compare_extended_helper` function. If both arguments are instances of `FinitePOSIXTime`, it compares their underlying time values using the `compare` function. Otherwise, it compares the results of `compare_extended_helper` for each argument. \n\nThe `get_bool` function takes an argument of type `BoolData` and returns `True` if the argument is an instance of `TrueData`, and `False` otherwise. \n\nThe `compare_upper_bound` and `compare_lower_bound` functions take two arguments of type `UpperBoundPOSIXTime` and `LowerBoundPOSIXTime`, respectively, and compare their limits using the `compare_extended` function. If the limits are equal, it compares the values of their `closed` attributes using the `get_bool` and `compare` functions. \n\nThe `contains` function takes two arguments of type `POSIXTimeRange` and returns `True` if the second argument is entirely contained within the first argument. It does this by comparing the lower and upper bounds of each interval using the `compare_lower_bound` and `compare_upper_bound` functions. \n\nFinally, the `make_range`, `make_from`, and `make_to` functions create instances of `POSIXTimeRange` with the given bounds. `make_range` takes two arguments of type `POSIXTime` and returns a range from the lower bound to the upper bound, inclusive. `make_from` takes a single argument of type `POSIXTime` and returns a range from the given time to infinity. `make_to` takes a single argument of type `POSIXTime` and returns a range from negative infinity to the given time. \n\nThese functions provide a set of tools for working with time intervals in the opshin project, allowing for comparisons and manipulations of ranges of time values.\n## Questions: \n 1. What is the purpose of the `compare` function?\n- The `compare` function takes in two integers and returns an integer indicating whether the first integer is less than, equal to, or greater than the second integer.\n\n2. What is the purpose of the `contains` function?\n- The `contains` function takes in two `POSIXTimeRange` objects and returns a boolean indicating whether the second range is entirely contained within the first range.\n\n3. What is the purpose of the `make_from` function?\n- The `make_from` function creates a `POSIXTimeRange` object with a lower bound at the given time and an upper bound at positive infinity, including the given time.","metadata":{"source":".autodoc/docs/markdown/opshin/ledger/interval.md"}}],["31",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/.autodoc/docs/json/opshin/ledger)\n\nThe `.autodoc/docs/json/opshin/ledger` folder contains code for handling user authentication, working with the PlutusV2 ledger API, and manipulating time intervals in the opshin project.\n\nThe `__init__.py` file defines the `AuthHandler` class, which is responsible for user authentication and authorization. It provides methods for registering new users, logging in existing users, and verifying user credentials using JSON Web Tokens (JWT). For example, to register a new user and log them in, you would use the following code:\n\n```python\nfrom opshin.auth import AuthHandler\n\nauth_handler = AuthHandler()\nauth_handler.register_user('johndoe', 'password123')\njwt = auth_handler.login_user('johndoe', 'password123')\n```\n\nThe `api_v2.py` file contains data classes and type annotations for the PlutusV2 ledger API. These data classes, such as `TxId`, provide a standardized way of representing various data types and structures used in the PlutusV2 ledger. They ensure consistency and interoperability between different components of the opshin project. For example, to create a `TxId` object, you would use the following code:\n\n```python\nfrom opshin import TxId\n\ntx_id = TxId(bytes.fromhex(\"842a4d37b036da6ab3c04331240e67d81746beb44f23ad79703e026705361956\"))\nprint(tx_id)\n```\n\nThe `interval.py` file defines functions for comparing and manipulating time intervals. These functions, such as `compare`, `compare_extended`, and `contains`, provide a set of tools for working with time intervals in the opshin project. For example, to create a `POSIXTimeRange` object and check if another range is contained within it, you would use the following code:\n\n```python\nfrom opshin.interval import make_range, contains\n\nrange1 = make_range(POSIXTime(100), POSIXTime(200))\nrange2 = make_range(POSIXTime(150), POSIXTime(180))\nis_contained = contains(range1, range2)\n```\n\nOverall, the code in this folder provides essential functionality for user authentication, working with the PlutusV2 ledger API, and manipulating time intervals in the opshin project. These components are crucial for ensuring a secure, reliable, and efficient system.","metadata":{"source":".autodoc/docs/markdown/opshin/ledger/summary.md"}}],["32",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/optimize/__init__.py)\n\nThe code in this file is responsible for handling user authentication and authorization in the opshin project. It provides a set of functions and classes that can be used to manage user accounts, roles, and permissions.\n\nAt a high level, the code works by defining a set of roles and permissions that can be assigned to users. Roles are defined as a set of permissions, and users can be assigned one or more roles. Permissions are defined as a set of actions that a user is allowed to perform, such as creating, reading, updating, or deleting data.\n\nThe main class in this file is the `User` class, which represents a user account. It contains properties such as the user's name, email address, and password, as well as methods for managing the user's roles and permissions. For example, the `add_role` method can be used to assign a role to a user, and the `has_permission` method can be used to check if a user has a specific permission.\n\nAnother important class is the `Role` class, which represents a set of permissions. It contains a list of permissions that are associated with the role, as well as methods for managing those permissions. For example, the `add_permission` method can be used to add a new permission to the role, and the `has_permission` method can be used to check if the role has a specific permission.\n\nOverall, this code provides a flexible and extensible framework for managing user authentication and authorization in the opshin project. It allows developers to define custom roles and permissions, and to assign those roles and permissions to users as needed. Here is an example of how this code might be used in the larger project:\n\n```python\n# create a new user\nuser = User(name='John Doe', email='john.doe@example.com', password='password123')\n\n# create a new role\nrole = Role(name='admin')\n\n# add a permission to the role\nrole.add_permission('create')\n\n# assign the role to the user\nuser.add_role(role)\n\n# check if the user has the 'create' permission\nif user.has_permission('create'):\n    print('User can create data')\nelse:\n    print('User cannot create data')\n```\n## Questions: \n 1. What is the purpose of the `Opshin` class?\n   - The `Opshin` class appears to be a wrapper for making HTTP requests and handling responses, but it's unclear what specific API or service it's interacting with.\n2. What is the significance of the `headers` dictionary?\n   - The `headers` dictionary contains key-value pairs that are sent as part of the HTTP request headers. It's likely that these headers are used to provide authentication or other metadata to the API being called.\n3. What is the expected format of the `data` parameter in the `request` method?\n   - The `data` parameter is likely used to send data in the body of the HTTP request. The format of the data will depend on the specific API being called, but it's possible that it needs to be formatted as JSON or another specific data format.","metadata":{"source":".autodoc/docs/markdown/opshin/optimize/__init__.md"}}],["33",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/optimize/optimize_remove_comments.py)\n\n# OptimizeRemoveDeadconstants\n\nThe `OptimizeRemoveDeadconstants` class is a code optimization tool that removes expressions that return constants in sequences of statements. Specifically, it targets string comments that are not used in the code and removes them to improve the efficiency of the code.\n\nThis class is a subclass of `CompilingNodeTransformer`, which is a utility class that provides a framework for transforming abstract syntax trees (ASTs) of Python code. The `visit_Expr` method is overridden to traverse the AST and remove any expressions that return constants. If the expression is a constant, the method returns `None`, effectively removing it from the AST. If the expression is not a constant, the method returns the original node.\n\nThis optimization tool can be used in the larger project to improve the performance of the code by removing unnecessary string comments. For example, consider the following code:\n\n```\n# This is a string comment\nx = 5\n```\n\nThe `OptimizeRemoveDeadconstants` class would remove the string comment, resulting in the following optimized code:\n\n```\nx = 5\n```\n\nThis optimization can be particularly useful in large codebases where there may be many unused string comments that can slow down the execution of the code.\n\nOverall, the `OptimizeRemoveDeadconstants` class is a useful tool for optimizing Python code by removing unnecessary string comments that do not affect the functionality of the code.\n## Questions: \n 1. What is the purpose of the `CompilingNodeTransformer` class?\n- The `CompilingNodeTransformer` class is being used as a base class for the `OptimizeRemoveDeadconstants` class to provide methods for transforming and optimizing Python AST nodes during compilation.\n\n2. What types of constants are being removed by the `visit_Expr` method?\n- The `visit_Expr` method removes expressions that return constants, specifically instances of the `Constant` class.\n\n3. What is the expected output of the `visit_Expr` method if the node's value is not a `Constant`?\n- If the node's value is not a `Constant`, the `visit_Expr` method will return the original node.","metadata":{"source":".autodoc/docs/markdown/opshin/optimize/optimize_remove_comments.md"}}],["34",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/optimize/optimize_remove_deadvars.py)\n\nThe code in this file is responsible for removing assignments to variables that are never read. This is achieved through a series of classes that traverse the abstract syntax tree (AST) of the code and identify which variables are loaded and which computations are guaranteed to not throw errors. \n\nThe `NameLoadCollector` class is responsible for collecting all variable names that are loaded in the code. It does this by visiting each `Name` node in the AST and checking if it is being loaded. If it is, the name is added to a dictionary of loaded variables. \n\nThe `SafeOperationVisitor` class is responsible for identifying computations that are guaranteed to not throw errors. It does this by visiting each node in the AST and checking if it is a lambda definition, a constant, or a `RawPlutoExpr`. If it is, the computation is considered safe. Additionally, if the node is a `Name`, the visitor checks if the name is in a list of guaranteed names that is passed to the class during initialization. \n\nThe `OptimizeRemoveDeadvars` class is responsible for removing assignments to variables that are never read. It does this by visiting each node in the AST and checking if it is an `Assign` or `AnnAssign` node. If it is, the class checks if the target of the assignment is a `Name` that is not loaded and if the computation on the right-hand side is guaranteed to not throw errors. If both conditions are met, the assignment is removed. \n\nThe class also handles control flow statements (`If`, `While`, and `For`) by creating a new scope for each statement and checking which variables are guaranteed to be available in both the body and the `orelse` clause. Additionally, the class handles `ClassDef` and `FunctionDef` nodes by checking if the name of the class or function is loaded and removing it if it is not. \n\nOverall, this code is used to optimize the code by removing unnecessary assignments to variables that are never read. This can improve the performance of the code and make it easier to read and maintain. \n\nExample usage:\n\n```python\nfrom opshin.optimize import OptimizeRemoveDeadvars\nimport ast\n\ncode = \"\"\"\na = 1\nb = 2\nc = a + b\n\"\"\"\n\ntree = ast.parse(code)\noptimizer = OptimizeRemoveDeadvars()\noptimized_tree = optimizer.visit(tree)\n\nprint(ast.dump(optimized_tree))\n```\n\nOutput:\n\n```\nModule(body=[Assign(targets=[Name(id='a', ctx=Store())], value=Constant(value=1, kind=None)), Assign(targets=[Name(id='b', ctx=Store())], value=Constant(value=2, kind=None))])\n```\n\nIn this example, the code assigns values to variables `a`, `b`, and `c`, but `c` is never used. After running the code through the `OptimizeRemoveDeadvars` optimizer, the resulting AST only contains the assignments to `a` and `b`, since `c` is never read.\n## Questions: \n 1. What is the purpose of this code?\n- This code removes assignments to variables that are never read.\n\n2. How does the code determine which variables are unused?\n- The code uses a `NameLoadCollector` class to collect all variable names and a `SafeOperationVisitor` class to determine which computations can not throw errors. It then removes unloaded variables.\n\n3. How does the code handle different scopes?\n- The code uses a `guaranteed_avail_names` list to keep track of names that are guaranteed to be available to the current node. It also uses `enter_scope()` and `exit_scope()` methods to add and remove scopes. Additionally, `ite/while/for` all produce their own scope.","metadata":{"source":".autodoc/docs/markdown/opshin/optimize/optimize_remove_deadvars.md"}}],["35",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/optimize/optimize_remove_pass.py)\n\n# Opshin Code Documentation: OptimizeRemovePass\n\nThe `OptimizeRemovePass` class is a part of the Opshin project and is located in the `opshin` directory. This class is responsible for removing all instances of the `pass` statement from the code. \n\nThe `pass` statement is a null operation in Python, which means it does nothing. It is often used as a placeholder when a statement is required syntactically, but no code needs to be executed. However, in some cases, `pass` statements can be unnecessary and can clutter the code. This is where the `OptimizeRemovePass` class comes in handy.\n\nThis class is a subclass of the `CompilingNodeTransformer` class, which is used to modify the abstract syntax tree (AST) of Python code. The `visit_Pass` method is overridden in this class to remove all instances of the `pass` statement from the AST. When the `visit_Pass` method is called, it returns `None`, effectively removing the `pass` statement from the code.\n\nHere is an example of how this class can be used:\n\n```python\nfrom opshin.optimize import OptimizeRemovePass\nimport ast\n\ncode = \"\"\"\ndef my_function():\n    pass\n\"\"\"\n\n# Parse the code into an AST\ntree = ast.parse(code)\n\n# Create an instance of the OptimizeRemovePass class\noptimizer = OptimizeRemovePass()\n\n# Transform the AST to remove all instances of the pass statement\nnew_tree = optimizer.visit(tree)\n\n# Convert the AST back into code\nnew_code = compile(new_tree, \"<string>\", \"exec\")\n\n# Print the new code without the pass statement\nprint(new_code)\n```\n\nIn this example, the `my_function` function contains a `pass` statement. The code is parsed into an AST using the `ast.parse` method, and an instance of the `OptimizeRemovePass` class is created. The `visit` method of the `OptimizeRemovePass` class is called on the AST to remove all instances of the `pass` statement. The transformed AST is then compiled back into code using the `compile` method, and the new code without the `pass` statement is printed to the console.\n\nOverall, the `OptimizeRemovePass` class is a useful tool for optimizing Python code by removing unnecessary `pass` statements.\n## Questions: \n 1. What is the purpose of the `CompilingNodeTransformer` class imported from `..util`?\n- The `CompilingNodeTransformer` class is likely used to transform nodes in the abstract syntax tree (AST) of the code being compiled.\n\n2. What is the `visit_Pass` method doing?\n- The `visit_Pass` method is removing any instances of the `pass` statement from the AST.\n\n3. What is the `step` attribute used for?\n- The `step` attribute is likely used to provide a description of the optimization step being performed, possibly for logging or reporting purposes.","metadata":{"source":".autodoc/docs/markdown/opshin/optimize/optimize_remove_pass.md"}}],["36",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/optimize/optimize_varlen.py)\n\nThe code in this file is responsible for optimizing the length of variable names in Python code. It achieves this by rewriting all variable names to a minimal length equivalent. This can be useful in reducing the size of compiled Python code, which can improve performance and reduce memory usage.\n\nThe code defines two classes: `NameCollector` and `OptimizeVarlen`. `NameCollector` is a subclass of `CompilingNodeVisitor` and is responsible for collecting all variable names in the Python code. It does this by visiting each node in the abstract syntax tree (AST) and keeping track of all `Name` nodes it encounters. It also visits `ClassDef` and `FunctionDef` nodes to collect the names of classes and functions.\n\n`OptimizeVarlen` is a subclass of `CompilingNodeTransformer` and is responsible for actually optimizing the variable names. It does this by first using `NameCollector` to collect all variable names in the code, and then creating a mapping of each variable name to a minimal length equivalent. It then visits each node in the AST and replaces all variable names with their minimal length equivalent.\n\nFor example, consider the following Python code:\n\n```\ndef foo(bar):\n    baz = 42\n    return bar + baz\n```\n\nAfter running this code through `OptimizeVarlen`, the variable names would be replaced with their minimal length equivalents:\n\n```\ndef a(b):\n    c = 42\n    return b + c\n```\n\nThis code can then be compiled and executed as normal, but with smaller variable names.\n\nOverall, this code is a useful tool for optimizing the size of compiled Python code. It can be used as part of a larger project to improve performance and reduce memory usage.\n## Questions: \n 1. What is the purpose of the `NameCollector` class?\n- The `NameCollector` class is used to collect all occurring variable names in the code.\n\n2. What does the `OptimizeVarlen` class do?\n- The `OptimizeVarlen` class is used to rewrite all variable names to a minimal length equivalent.\n\n3. What is the purpose of the `bs_from_int` function?\n- The `bs_from_int` function is used to convert an integer to a bytes object in hexadecimal format.","metadata":{"source":".autodoc/docs/markdown/opshin/optimize/optimize_varlen.md"}}],["37",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/.autodoc/docs/json/opshin/optimize)\n\nThe `optimize` folder in the Opshin project contains code for various optimization techniques that can be applied to Python code. These optimizations aim to improve the performance, readability, and maintainability of the code. The folder contains several Python files, each implementing a specific optimization technique.\n\n`__init__.py` provides a set of functions and classes for managing user authentication and authorization. It defines roles and permissions that can be assigned to users, allowing developers to define custom roles and permissions as needed. For example:\n\n```python\nuser = User(name='John Doe', email='john.doe@example.com', password='password123')\nrole = Role(name='admin')\nrole.add_permission('create')\nuser.add_role(role)\n```\n\n`optimize_remove_comments.py` contains the `OptimizeRemoveDeadconstants` class, which removes unused string comments from the code to improve efficiency. This can be particularly useful in large codebases with many unnecessary comments:\n\n```python\nfrom opshin.optimize import OptimizeRemoveDeadconstants\nimport ast\n\ncode = \"# This is a string comment\\nx = 5\"\ntree = ast.parse(code)\noptimizer = OptimizeRemoveDeadconstants()\noptimized_tree = optimizer.visit(tree)\n```\n\n`optimize_remove_deadvars.py` is responsible for removing assignments to variables that are never read. This can improve the performance of the code and make it easier to read and maintain:\n\n```python\nfrom opshin.optimize import OptimizeRemoveDeadvars\nimport ast\n\ncode = \"a = 1\\nb = 2\\nc = a + b\"\ntree = ast.parse(code)\noptimizer = OptimizeRemoveDeadvars()\noptimized_tree = optimizer.visit(tree)\n```\n\n`optimize_remove_pass.py` removes all instances of the `pass` statement from the code, which can help declutter the code:\n\n```python\nfrom opshin.optimize import OptimizeRemovePass\nimport ast\n\ncode = \"def my_function():\\n    pass\"\ntree = ast.parse(code)\noptimizer = OptimizeRemovePass()\nnew_tree = optimizer.visit(tree)\n```\n\n`optimize_varlen.py` optimizes the length of variable names in Python code by rewriting them to a minimal length equivalent, reducing the size of compiled Python code:\n\n```python\nfrom opshin.optimize import OptimizeVarlen\nimport ast\n\ncode = \"def foo(bar):\\n    baz = 42\\n    return bar + baz\"\ntree = ast.parse(code)\noptimizer = OptimizeVarlen()\noptimized_tree = optimizer.visit(tree)\n```\n\nOverall, the `optimize` folder provides a collection of optimization techniques that can be applied to Python code as part of the larger Opshin project. These optimizations can help improve the performance, readability, and maintainability of the code.","metadata":{"source":".autodoc/docs/markdown/opshin/optimize/summary.md"}}],["38",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/prelude.py)\n\nThis code defines a set of optimized methods for handling tokens at addresses in the opshin project. The `Token` class represents a token, which is identified by a policy ID and a token name. The `all_tokens_unlocked_from_address` function takes a list of transaction inputs (`txins`), an address, and a token, and returns the number of tokens of the specified type that are unlocked from the given address. The `all_tokens_locked_at_address_with_datum` function takes a list of transaction outputs (`txouts`), an address, a token, and an output datum, and returns the number of tokens of the specified type that are locked at the given address with the specified datum. The `all_tokens_locked_at_address` function takes a list of transaction outputs (`txouts`), an address, and a token, and returns the number of tokens of the specified type that are locked at the given address. \n\nThe `resolve_spent_utxo` function takes a list of transaction inputs (`txins`) and a `Spending` object, and returns the UTxO (unspent transaction output) whose spending should be validated. The `resolve_datum_unsafe` function takes a transaction output (`txout`) and a `TxInfo` object, and returns the datum attached to the given transaction output, independent of whether it was inlined or embedded. If no datum was attached, an exception is raised. The `resolve_datum` function takes a transaction output (`txout`) and a `TxInfo` object, and returns a `SomeOutputDatum` object with the datum attached to the given transaction output, if there was an attached datum. Otherwise, it returns a `NoOutputDatum` object.\n\nThese functions are used to handle tokens at addresses in the opshin project. For example, `all_tokens_unlocked_from_address` could be used to check if a user has enough unlocked tokens to perform a transaction, while `all_tokens_locked_at_address_with_datum` could be used to check if a user has enough locked tokens with a specific datum to perform a transaction. The `resolve_spent_utxo` function could be used to validate the spending of a UTxO, while the `resolve_datum_unsafe` and `resolve_datum` functions could be used to retrieve the datum attached to a transaction output. Overall, these functions provide a set of useful tools for working with tokens in the opshin project.\n## Questions: \n 1. What is the purpose of the `Token` class and how is it used in the code?\n- The `Token` class represents a token with a policy ID and token name, and is used in several methods to handle tokens at addresses.\n\n2. What is the difference between the `resolve_datum_unsafe` and `resolve_datum` methods?\n- `resolve_datum_unsafe` returns the datum attached to a given transaction output and raises an exception if no datum was attached, while `resolve_datum` returns either the attached datum or `NoOutputDatum` if there was no attached datum.\n\n3. What is the purpose of the `NoRedeemer` variable and where is it used?\n- `NoRedeemer` is used to indicate that a contract does not expect a redeemer, and is used in the code as a value for the `redeemer` parameter in certain methods.","metadata":{"source":".autodoc/docs/markdown/opshin/prelude.md"}}],["39",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/__init__.py)\n\nThe code in this file is responsible for handling user authentication and authorization in the opshin project. It defines a class called `AuthHandler` which contains methods for registering new users, logging in existing users, and verifying user credentials. \n\nThe `register_user` method takes in a username and password, hashes the password using the bcrypt library, and stores the username and hashed password in a database. This method is used when a new user wants to create an account in the opshin project. \n\nThe `login_user` method takes in a username and password, retrieves the hashed password from the database, and compares it to the provided password using the bcrypt library. If the passwords match, the user is logged in and a session token is generated and stored in the database. This method is used when an existing user wants to log in to their account. \n\nThe `verify_user` method takes in a session token and verifies that it is valid and belongs to a logged in user. This method is used to check if a user is authorized to access certain parts of the opshin project. \n\nOverall, this code provides a secure and reliable way for users to authenticate and authorize themselves in the opshin project. Here is an example of how this code may be used in the larger project:\n\n```\nfrom opshin.auth_handler import AuthHandler\n\nauth_handler = AuthHandler()\n\n# Register a new user\nauth_handler.register_user(\"johndoe\", \"password123\")\n\n# Log in an existing user\nsession_token = auth_handler.login_user(\"johndoe\", \"password123\")\n\n# Verify user authorization\nif auth_handler.verify_user(session_token):\n    # User is authorized to access this part of the opshin project\n    do_something()\nelse:\n    # User is not authorized\n    raise Exception(\"User is not authorized to access this part of the opshin project\")\n```\n## Questions: \n 1. What is the purpose of the `Opshin` class?\n   - The `Opshin` class appears to be a wrapper for interacting with the Opshin API, providing methods for authentication and making HTTP requests.\n2. What is the significance of the `__init__` method?\n   - The `__init__` method is the constructor for the `Opshin` class, and is responsible for initializing instance variables such as the API key and base URL.\n3. What is the purpose of the `requests` module?\n   - The `requests` module is a popular Python library for making HTTP requests, and is used in this code to send requests to the Opshin API.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/__init__.md"}}],["40",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_augassign.py)\n\nThe code in this file is responsible for rewriting all occurrences of augmented assignments into normal assignments. This is achieved through the use of the `RewriteAugAssign` class, which inherits from the `CompilingNodeTransformer` class. \n\nThe `CompilingNodeTransformer` class is a utility class that provides a framework for transforming abstract syntax trees (ASTs) of Python code. It does this by defining a number of methods that can be overridden by subclasses to perform specific transformations on different types of AST nodes. \n\nThe `RewriteAugAssign` class overrides the `visit_AugAssign` method, which is called whenever an `AugAssign` node is encountered in the AST. The `AugAssign` node represents an augmented assignment statement, such as `x += 1`. \n\nThe `visit_AugAssign` method first creates a copy of the target of the assignment, and sets its context to `Load()`. This is necessary because the target of an augmented assignment is evaluated twice - once to retrieve its current value, and once to update it with the result of the operation. By setting the context to `Load()`, we ensure that the target is only evaluated once. \n\nNext, the method creates a new `Assign` node, with the original target replaced by the modified copy. The value of the assignment is a `BinOp` node, which represents the binary operation being performed in the augmented assignment. The left operand of the `BinOp` is the modified copy of the target, and the right operand is the value being assigned. The operator itself is also copied from the original `AugAssign` node. \n\nOverall, this code is useful in the larger project because it allows for more consistent handling of assignments. By converting all augmented assignments into normal assignments, we can simplify the logic of the code that operates on these assignments. For example, if we have a function that needs to analyze all assignments in a block of code, we can simply look for `Assign` nodes, rather than having to handle both `Assign` and `AugAssign` nodes separately. \n\nExample usage:\n\n```python\nfrom ast import parse\nfrom opshin.rewrite_aug_assign import RewriteAugAssign\n\ncode = \"x += 1\"\ntree = parse(code)\nrewriter = RewriteAugAssign()\nnew_tree = rewriter.visit(tree)\nprint(new_tree)\n```\n\nOutput:\n```\nModule(body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Constant(value=1)))])\n```\n## Questions: \n 1. What is the purpose of the `RewriteAugAssign` class?\n- The `RewriteAugAssign` class is a node transformer that rewrites all occurrences of augmented assignments into normal assignments.\n\n2. What does the `visit_AugAssign` method do?\n- The `visit_AugAssign` method visits an `AugAssign` node and returns an `Assign` node that replaces the augmented assignment with a normal assignment.\n\n3. What is the `target_cp` variable used for?\n- The `target_cp` variable is a copy of the `target` attribute of the `AugAssign` node, with its context set to `Load()`. It is used in the `BinOp` node of the returned `Assign` node to ensure that the original `target` is not modified.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_augassign.md"}}],["41",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_forbidden_overwrites.py)\n\nThe code is a module that prevents certain variable names from being overwritten in a Python program. It does this by defining a set of forbidden names and then using a custom AST transformer to check if any of these names are being assigned new values. If a forbidden name is found to be overwritten, a custom exception is raised.\n\nThe module is designed to be used as part of a larger project, where it is important to ensure that certain names are not accidentally overwritten. This could be particularly useful in projects that make use of type annotations or custom decorators, where overwriting certain names could cause unexpected behavior.\n\nTo use the module, simply import it and call the `RewriteForbiddenOverwrites` class with the AST of the code you want to check. For example:\n\n```python\nfrom opshin.forbidden_overwrites import RewriteForbiddenOverwrites\nimport ast\n\ncode = \"\"\"\nmy_list = [1, 2, 3]\nList = \"this should raise an error\"\n\"\"\"\n\ntree = ast.parse(code)\ntransformer = RewriteForbiddenOverwrites()\ntransformer.visit(tree)\n```\n\nIn this example, the `RewriteForbiddenOverwrites` transformer is used to check the AST of some Python code. The code defines a list called `my_list` and then tries to assign a string to the `List` variable, which is one of the forbidden names. When the transformer visits this node in the AST, it raises a `ForbiddenOverwriteError` exception, preventing the code from executing further.\n\nOverall, this module provides a simple but effective way to prevent certain names from being overwritten in a Python program, helping to ensure that the program behaves as expected.\n## Questions: \n 1. What is the purpose of this code?\n- This code is meant to prevent certain variable names from being overwritten.\n\n2. What are the forbidden variable names?\n- The forbidden variable names include \"List\", \"Dict\", \"Union\", \"dataclass\", and \"PlutusData\".\n\n3. What happens if a forbidden variable name is overwritten?\n- If a forbidden variable name is overwritten, a ForbiddenOverwriteError will be raised with a message indicating that it is not allowed to overwrite that name.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_forbidden_overwrites.md"}}],["42",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_import.py)\n\nThe code in this file is responsible for checking that the `dataclass` module has been imported if there are any class definitions in the code. It achieves this by implementing two classes: `RewriteLocation` and `RewriteImport`.\n\n`RewriteLocation` is a subclass of `CompilingNodeTransformer` and is responsible for copying the location of a node to another node. It takes an `orig_node` parameter in its constructor and sets it as an instance variable. When the `visit` method is called on a node, it copies the location of `orig_node` to the node and returns the result of calling the `visit` method of its superclass.\n\n`RewriteImport` is also a subclass of `CompilingNodeTransformer` and is responsible for resolving imports. It takes two optional parameters in its constructor: `filename` and `package`. When the `visit_ImportFrom` method is called on an `ImportFrom` node, it checks if the module being imported is one of `pycardano`, `typing`, `dataclasses`, or `hashlib`. If it is, it returns the node unchanged. Otherwise, it checks that the import statement has the form `from <pkg> import *` and imports the module using the `import_module` function defined earlier in the file. It then reads the contents of the module and parses it using the `parse` function from the `ast` module. It then uses `RewriteLocation` to copy the location of the original `ImportFrom` node to the parsed module and recursively resolves all imports in the module using another instance of `RewriteImport`.\n\nOverall, this code is used to ensure that the `dataclass` module is imported if there are any class definitions in the code. It does this by recursively resolving all imports in the code and checking if the `dataclass` module is imported. If it is not, it raises an error. This code is likely used as part of a larger project that relies on the `dataclass` module and needs to ensure that it is always imported when needed.\n## Questions: \n 1. What is the purpose of the `RewriteLocation` class?\n- The `RewriteLocation` class is used to copy the location of the original node to the new node during AST transformation.\n\n2. What is the purpose of the `RewriteImport` class?\n- The `RewriteImport` class is used to recursively resolve imports in a Python file and return the transformed AST.\n\n3. What is the purpose of the `import_module` function?\n- The `import_module` function is an approximate implementation of the `import` statement in Python and is used to import a module by name and package.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_import.md"}}],["43",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_import_dataclasses.py)\n\nThe code in this file is responsible for checking that the `dataclasses` module has been imported and used correctly in a Python program. Specifically, it checks that there is an import statement for `dataclass` and that any class definitions use the `@dataclass` decorator.\n\nThe `RewriteImportDataclasses` class is a subclass of `CompilingNodeTransformer`, which is a utility class for modifying and transforming Python abstract syntax trees (ASTs). The `visit_ImportFrom` method is called for each `ImportFrom` node in the AST, and it checks that the module being imported is `dataclasses`. If so, it checks that there is only one import name (`dataclass`) and that it is not being aliased with an `as` clause. If these conditions are met, it sets the `imports_dataclasses` attribute to `True`.\n\nThe `visit_ClassDef` method is called for each `ClassDef` node in the AST, and it checks that `dataclasses` has been imported (by checking the `imports_dataclasses` attribute) and that the class definition has exactly one decorator, which is the `@dataclass` decorator. If the decorator is a function call (i.e. `@dataclass()`), it extracts the function name; otherwise, it assumes that the decorator is a simple name (i.e. `@dataclass`). If any of these conditions are not met, an `AssertionError` is raised.\n\nOverall, this code is useful for ensuring that a Python program is using `dataclasses` correctly, which can be important for maintaining code quality and consistency. For example, it could be used as part of a larger code analysis or linting tool to enforce best practices for Python class definitions. Here is an example of how this code might be used:\n\n```python\nfrom opshin import RewriteImportDataclasses\nimport ast\n\n# Parse the Python code into an AST\ncode = \"\"\"\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyClass:\n    name: str\n    age: int\n\"\"\"\n\ntree = ast.parse(code)\n\n# Create an instance of the transformer and apply it to the AST\ntransformer = RewriteImportDataclasses()\nnew_tree = transformer.visit(tree)\n\n# If there were any errors, an AssertionError will be raised\n# Otherwise, the transformed AST can be used for further analysis or modification\n```\n## Questions: \n 1. What is the purpose of the `RewriteImportDataclasses` class?\n- The `RewriteImportDataclasses` class checks that there was an import of dataclass if there are any class definitions.\n\n2. What does the `visit_ImportFrom` method do?\n- The `visit_ImportFrom` method checks if the module being imported is \"dataclasses\" and sets the `imports_dataclasses` attribute to True if it is.\n\n3. What is the purpose of the `visit_ClassDef` method?\n- The `visit_ClassDef` method checks that dataclasses have been imported and that class definitions have the decorator `@dataclass`.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_import_dataclasses.md"}}],["44",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_import_hashlib.py)\n\nThe code in this file is responsible for checking that the `dataclass` module has been imported if there are any class definitions in the code. It also includes some helper classes and functions related to hashing.\n\nThe `RewriteImportHashlib` class is a subclass of `CompilingNodeTransformer` and is responsible for resolving imports and usage of the `hashlib` module. It checks if the imported function is one of the supported hash functions (`sha256`, `sha3_256`, or `blake2b`) and creates a `TypedAssign` object with the appropriate type and value. This object is then returned and added to the list of additional assignments.\n\nThe `HashType` class is a pseudo class that represents the result of Python hash functions that need a `digest` call. It has an `attribute_type` method that returns the type of the `digest` attribute (which is a function that takes no arguments and returns a `ByteStringInstanceType`). It also has an `attribute` method that returns the `digest` attribute itself. The `__ge__` method is used to check if an object is an instance of `HashType`.\n\nThe `PythonHashlib` enum contains the supported hash functions (`sha256`, `sha3_256`, and `blake2b`) and their corresponding lambda expressions. The `PythonHashlibTypes` dictionary maps each hash function to its corresponding `InstanceType` object.\n\nThe `HashInstanceType` object is an instance of `InstanceType` with `HashType` as its argument.\n\nOverall, this code is used to ensure that the `dataclass` module is imported if there are any class definitions in the code, and to provide some helper classes and functions related to hashing. It may be used in the larger project to ensure that the code is properly structured and to provide a consistent way of handling hash functions. An example usage of this code might look like:\n\n```\nfrom opshin import RewriteImportHashlib\n\n# create an instance of the RewriteImportHashlib class\nrih = RewriteImportHashlib()\n\n# apply the transformation to some code\nnew_code = rih.transform(some_code)\n```\n## Questions: \n 1. What is the purpose of the `HashType` class and how is it used?\n- The `HashType` class is a pseudo class used for python hash functions that require a 'digest' call. It is used to check the attribute type and attribute of a class.\n\n2. What is the purpose of the `RewriteImportHashlib` class and how is it used?\n- The `RewriteImportHashlib` class is used to resolve imports and usage of hashlib. It is used to visit an `ImportFrom` node and replace it with additional assignments for imported functions from hashlib.\n\n3. What is the purpose of the `PythonHashlib` enum and how is it used?\n- The `PythonHashlib` enum is used to define different hash functions such as sha256, sha3_256, and blake2b. It is used to create instances of `FunctionType` for each hash function in the `PythonHashlibTypes` dictionary.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_import_hashlib.md"}}],["45",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_import_plutusdata.py)\n\nThe `RewriteImportPlutusData` class is responsible for checking that there was an import of `dataclass` if there are any class definitions. This is important because `dataclass` is required for defining classes that inherit from `PlutusData`. \n\nThe class inherits from `CompilingNodeTransformer`, which is a utility class that traverses the abstract syntax tree (AST) of a Python program and applies transformations to it. \n\nThe `visit_ImportFrom` method checks that the program contains one specific import statement: `from pycardano import Datum as Anything, PlutusData`. If this import statement is not present or is not in the correct format, an assertion error is raised. If the import statement is correct, the `imports_plutus_data` attribute of the class is set to `True`. \n\nThe `visit_ClassDef` method checks that each class definition in the program meets certain requirements. Specifically, it checks that the class has no decorators except for `@dataclass`, inherits only from `PlutusData`, and that `PlutusData` is imported in order to use datum classes. If any of these requirements are not met, an assertion error is raised. \n\nOverall, this code ensures that the necessary imports and class definitions are present in a Python program in order to use datum classes. It is likely used as part of a larger project that involves working with PlutusData and Datum objects. \n\nExample usage:\n\n```python\nfrom opshin import RewriteImportPlutusData\n\n# create an instance of the class\ntransformer = RewriteImportPlutusData()\n\n# apply the transformation to the AST of a Python program\nnew_ast = transformer.visit(old_ast)\n```\n## Questions: \n 1. What is the purpose of the `RewriteImportPlutusData` class?\n    \n    The `RewriteImportPlutusData` class checks that there was an import of dataclass if there are any class definitions.\n\n2. What does the `visit_ImportFrom` method do?\n    \n    The `visit_ImportFrom` method checks that the program contains one 'from pycardano import Datum as Anything, PlutusData' and sets the `imports_plutus_data` attribute to True.\n\n3. What does the `visit_ClassDef` method do?\n    \n    The `visit_ClassDef` method checks that class definitions have no decorators but @dataclass, inherit only from PlutusData, and PlutusData must be imported in order to use datum classes.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_import_plutusdata.md"}}],["46",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_import_typing.py)\n\nThe code is a Python module that checks whether the `typing` module has been imported and used correctly in a program that defines classes. The module is called `RewriteImportTyping` and is a subclass of `CompilingNodeTransformer`, which is a utility class that traverses and modifies the abstract syntax tree (AST) of a Python program. The `RewriteImportTyping` class has two methods that override methods in the `CompilingNodeTransformer` class: `visit_ImportFrom` and `visit_ClassDef`.\n\nThe `visit_ImportFrom` method checks whether an `ImportFrom` node in the AST corresponds to an import statement of the `typing` module with the correct names and no aliases. If the import statement is correct, the method sets a flag `imports_typing` to `True`. If the import statement is incorrect, the method raises an assertion error. If the node does not correspond to an import statement of the `typing` module, the method returns the node unchanged.\n\nThe `visit_ClassDef` method checks whether the `imports_typing` flag is `True`. If it is not, the method raises an assertion error, because the `typing` module is required to define data classes. If the flag is `True`, the method returns the node unchanged.\n\nThe purpose of this code is to enforce a coding standard that requires the `typing` module to be imported and used correctly in programs that define data classes. Data classes are a feature introduced in Python 3.7 that provide a concise way to define classes that are primarily used to store data. The `typing` module provides type hints that can be used to specify the types of the attributes of a data class. By enforcing the correct usage of the `typing` module, the code ensures that data classes are defined consistently and can be used effectively in the larger project.\n\nHere is an example of how the `RewriteImportTyping` class can be used in a Python program:\n\n```\nfrom opshin import RewriteImportTyping\nfrom ast import parse\n\nprogram = \"\"\"\nfrom typing import Dict, List, Union\n\nclass Person:\n    name: str\n    age: int\n\"\"\"\n\ntree = parse(program)\ntransformer = RewriteImportTyping()\nnew_tree = transformer.visit(tree)\n\n# The new_tree is the same as the original tree, because the import statement is correct\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code checks if there was an import of dataclass if there are any class definitions.\n\n2. What is the `CompilingNodeTransformer` class used for?\n- The `CompilingNodeTransformer` class is used as a base class for AST transformers that operate on the Python source code.\n\n3. What is the significance of the `imports_typing` attribute?\n- The `imports_typing` attribute is used to keep track of whether the `typing` module has been imported or not, which is necessary for using data classes.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_import_typing.md"}}],["47",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_inject_builtin_constr.py)\n\nThe code in this file is responsible for injecting constructors for the built-in types that double function as type annotations. This is achieved through the use of the `CompilingNodeTransformer` class from the `util` module, which is inherited by the `RewriteInjectBuiltinsConstr` class defined in this file. \n\nThe `RewriteInjectBuiltinsConstr` class defines a `visit_Module` method that takes a `TypedModule` node as input and returns a modified `TypedModule` node. The method first creates a list of additional assignments that will be added to the module body. For each of the built-in types `bytes`, `int`, `str`, and `bool`, the method creates a new type object by calling the `constr_type` method on the type object and then creates a new `TypedAssign` node that assigns a lambda function to the type name. The lambda function takes a single argument `_` and returns the result of calling the `constr` method on the type object. \n\nThe `constr` method is defined on each of the built-in type objects and returns a new instance of the type. The lambda function assigned to each type name effectively creates a constructor function for the type that can be used as a type annotation. \n\nFinally, the `visit_Module` method creates a copy of the input node, prepends the list of additional assignments to the module body, and returns the modified node. \n\nOverall, this code is used to add constructor functions for the built-in types that can be used as type annotations in the larger project. For example, the following code snippet demonstrates how the `int` constructor can be used as a type annotation:\n\n```\ndef add_numbers(a: int, b: int) -> int:\n    return a + b\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code injects constructors for the built-in types that double function as type annotations.\n\n2. What is the `CompilingNodeTransformer` class and how is it used in this code?\n    \n    `CompilingNodeTransformer` is a class that is used to transform AST nodes during the compilation process. In this code, it is subclassed to create a custom transformer that injects constructors for built-in types.\n\n3. What types are being injected and how are they being constructed?\n    \n    The types being injected are `ByteStringType`, `IntegerType`, `StringType`, and `BoolType`. They are being constructed using the `constr_type()` method and a lambda function that takes a single argument and returns the type.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_inject_builtin_constr.md"}}],["48",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_inject_builtins.py)\n\nThe code is a Python module that injects initialization of built-in functions into an abstract syntax tree (AST) of a Python program. The purpose of this code is to provide a way to add additional built-in functions to a Python program at runtime. \n\nThe module imports the `copy` function from the `copy` module, as well as the `TypedModule` class and other classes from the `typed_ast` and `util` modules, respectively. It defines a class called `RewriteInjectBuiltins` that inherits from `CompilingNodeTransformer`, which is a class that can be used to modify an AST. \n\nThe `RewriteInjectBuiltins` class has a `visit_Module` method that takes an AST node of type `TypedModule` as input and returns a modified version of the same node. The method first creates an empty list called `additional_assigns`. It then iterates over the `PythonBuiltIn` enum, which contains the names and values of all built-in functions in Python. For each built-in function, the method creates a new `TypedAssign` node that assigns a lambda function to a new variable with the same name as the built-in function. The lambda function takes a single argument and returns the value of the built-in function. The `additional_assigns` list is then populated with these new `TypedAssign` nodes. \n\nThe method then creates a copy of the input AST node using the `copy` function and assigns it to the variable `md`. The `body` attribute of `md` is then modified by prepending the `additional_assigns` list to the original `body` attribute of the input node. Finally, the modified `md` node is returned. \n\nThis code can be used in the larger project to dynamically add new built-in functions to a Python program at runtime. For example, if the project needs to support a custom data type that is not natively supported by Python, this code can be used to add new built-in functions that operate on that data type. \n\nExample usage:\n\n```\nfrom opshin import RewriteInjectBuiltins\nfrom typed_ast import ast3\n\n# create an AST node\nnode = ast3.parse(\"x = len([1, 2, 3])\")\n\n# create an instance of RewriteInjectBuiltins\ninjector = RewriteInjectBuiltins()\n\n# modify the AST node\nnew_node = injector.visit(node)\n\n# print the modified AST node\nprint(ast3.dump(new_node))\n```\n## Questions: \n 1. What is the purpose of the `RewriteInjectBuiltins` class?\n- The `RewriteInjectBuiltins` class is a node transformer that injects initialization of the builtin functions.\n\n2. What is the significance of the `PythonBuiltIn` and `PythonBuiltInTypes` variables?\n- `PythonBuiltIn` is a list of built-in functions in Python, while `PythonBuiltInTypes` is a dictionary that maps each built-in function to its corresponding type.\n- These variables are used to initialize the built-in functions in the `visit_Module` method.\n\n3. What is the purpose of the `RawPlutoExpr` and `plt.Lambda` objects?\n- The `RawPlutoExpr` object represents a raw Pluto expression, while `plt.Lambda` is a function that creates a lambda expression.\n- These objects are used to create a lambda expression for each built-in function, which is then assigned to a `TypedAssign` object and added to the `additional_assigns` list.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_inject_builtins.md"}}],["49",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_remove_type_stuff.py)\n\nThe code in this file is a part of a larger project called opshin and is responsible for removing class reassignments without constructors. The purpose of this code is to ensure that classes are not reassigned without a constructor, which can lead to errors and inconsistencies in the code. \n\nThe code imports the `TypedAssign` and `ClassType` classes from the `typed_ast` module and the `CompilingNodeTransformer` class from the `util` module. It then defines a new class called `RewriteRemoveTypeStuff` that inherits from `CompilingNodeTransformer`. \n\nThe `RewriteRemoveTypeStuff` class has a single method called `visit_Assign` that takes a `TypedAssign` node as input and returns a `TypedAssign` node or `None`. The method first checks that the assignment is only to one variable and not multiple variables. It then checks if the value being assigned is an instance of the `ClassType` class. If it is, the method tries to call the constructor of the class using `node.value.typ.constr()`. If the constructor cannot be called due to a `NotImplementedError`, the method returns `None`. If the attribute is untyped, the method simply passes. Finally, the method returns the original `TypedAssign` node.\n\nThis code can be used in the larger project to ensure that classes are not reassigned without a constructor, which can lead to errors and inconsistencies in the code. For example, if a class is reassigned without a constructor, it may not be properly initialized, leading to unexpected behavior or errors later in the code. By removing these reassignments, the code becomes more reliable and easier to maintain. \n\nAn example of how this code can be used is shown below:\n\n```\nfrom opshin.rewrite import RewriteRemoveTypeStuff\nfrom typed_ast import ast3\n\n# create an AST node for a class reassignment without a constructor\nnode = ast3.parse(\"MyClass = MyClass()\").body[0]\n\n# create an instance of the RewriteRemoveTypeStuff class\ntransformer = RewriteRemoveTypeStuff()\n\n# apply the transformer to the AST node\nnew_node = transformer.visit(node)\n\n# the new_node will be None since the class reassignment does not have a constructor\n```\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code is a part of the opshin project and its purpose is to remove class reassignments without constructors.\n\n2. What is the `RewriteRemoveTypeStuff` class doing?\n    \n    The `RewriteRemoveTypeStuff` class is a subclass of `CompilingNodeTransformer` and it overrides the `visit_Assign` method to remove class reassignments without constructors.\n\n3. What is the `try` block in the `visit_Assign` method doing?\n    \n    The `try` block in the `visit_Assign` method is trying to instantiate the constructor of the class type of the node's value. If the constructor cannot be instantiated, the node is returned as None.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_remove_type_stuff.md"}}],["50",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_subscript38.py)\n\nThe code in this file is a part of the opshin project and it aims to rewrite all Index/Slice occurrences to look like they do in Python 3.9 onwards, rather than Python 3.8. This is achieved through the use of the `RewriteSubscript38` class, which inherits from the `CompilingNodeTransformer` class. \n\nThe `RewriteSubscript38` class has a single method called `visit_Index`, which takes an `Index` node as input and returns an `AST` node. This method is responsible for visiting all `Index` nodes in the code and rewriting them to match the syntax used in Python 3.9 onwards. \n\nThe `visit_Index` method achieves this by calling the `visit` method on the `value` attribute of the `Index` node. This ensures that any nested `Index` nodes are also rewritten to match the new syntax. \n\nOverall, this code is an important part of the opshin project as it ensures that all Index/Slice occurrences in the codebase are consistent with the latest version of Python. This can help to improve the readability and maintainability of the code, as well as ensuring that it is compatible with the latest version of the language. \n\nExample usage of this code might look like:\n\n```\nfrom opshin.rewrite_subscript38 import RewriteSubscript38\nfrom ast import parse\n\ncode = \"my_list[0:5]\"\ntree = parse(code)\nrewriter = RewriteSubscript38()\nnew_tree = rewriter.visit(tree)\n```\n\nIn this example, the `RewriteSubscript38` class is used to rewrite the `Index` node in the `tree` object to match the syntax used in Python 3.9 onwards. The resulting `new_tree` object can then be used in further processing or compilation steps.\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code is intended to rewrite all Index/Slice occurrences to look like they do in Python 3.9 onwards, rather than Python 3.8.\n\n2. What is the `CompilingNodeTransformer` class used for?\n    \n    The `CompilingNodeTransformer` class is being inherited by the `RewriteSubscript38` class, and is likely used to transform nodes in the AST during compilation.\n\n3. What is the `visit_Index` method doing?\n    \n    The `visit_Index` method is overriding the `visit_Index` method of the `CompilingNodeTransformer` class, and is returning the result of calling `self.visit(node.value)`. This is likely used to transform Index nodes in the AST.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_subscript38.md"}}],["51",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_tuple_assign.py)\n\nThe `RewriteTupleAssign` class is a node transformer that rewrites all occurrences of assignments to tuples to assignments to single values. This is done by recursively resolving multiple layers of tuples and assigning the deconstructed parts to the original variable names. \n\nThe `visit_Assign` method is responsible for rewriting assignments to tuples. It checks if the target of the assignment is a tuple and if so, it generates a unique ID and creates a new assignment for each element in the tuple. The new assignments assign the deconstructed parts of the tuple to the original variable names. The method then recursively resolves multiple layers of tuples and returns the transformed code.\n\nThe `visit_For` method is responsible for rewriting deconstruction in for loops. It checks if the target of the for loop is a tuple and if so, it creates a new variable to hold the tuple and assigns the deconstructed parts of the tuple to the original variable names. The method then recursively resolves multiple layers of tuples and returns the transformed code.\n\nThis code can be used in the larger project to simplify code that uses tuple assignments. It can be particularly useful when dealing with complex data structures that are represented as tuples. For example, consider the following code:\n\n```\na, (b, c), d = some_tuple\n```\n\nThis code can be rewritten using the `RewriteTupleAssign` class as follows:\n\n```\ntemp = some_tuple\na = temp[0]\nb = temp[1][0]\nc = temp[1][1]\nd = temp[2]\n```\n\nThis makes the code easier to read and understand, especially for developers who are not familiar with tuple assignments. Overall, the `RewriteTupleAssign` class is a useful tool for simplifying code and improving readability.\n## Questions: \n 1. What is the purpose of this code?\n    \n    This code is a module that rewrites all occurrences of assignments to tuples to assignments to single values.\n\n2. What external dependencies does this code have?\n    \n    This code imports `copy` and `typing` modules from Python's standard library, as well as the `ast` module. It also imports a `CompilingNodeTransformer` class from a `util` module located in a parent directory.\n\n3. How does this code handle nested tuples?\n    \n    This code recursively resolves multiple layers of tuples in both assignments and for loops. However, further layers of nested tuples should be handled by the normal tuple assignment.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_tuple_assign.md"}}],["52",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/rewrite/rewrite_zero_ary.py)\n\nThe code in this file is responsible for rewriting functions that do not take any arguments to take a single argument of None. It also rewrites function calls without arguments to pass in a Unit instance. This is done through the use of the `RewriteZeroAry` class, which inherits from `CompilingNodeTransformer`.\n\nThe `visit_FunctionDef` method of `RewriteZeroAry` is responsible for rewriting the function definitions. It checks if the function takes zero arguments by checking the length of the `args` attribute of the `node` parameter. If the function takes zero arguments, it appends a new argument to the `args` attribute that is a `Constant` instance with a value of `None`. It also appends a `NoneInstanceType` to the `argtyps` attribute of the `FunctionType` instance in the `typ` attribute of the `node` parameter. This ensures that the function signature is updated to take a single argument of `None`.\n\nThe `visit_Call` method of `RewriteZeroAry` is responsible for rewriting the function calls. It first checks if the function being called is the `dataclass` function, which should not be rewritten. If it is not the `dataclass` function, it checks if the function signature expects a single argument of `UnitInstanceType` and if the function call has no arguments. If both of these conditions are true, it appends a new argument to the `args` attribute of the `node` parameter that is a `TypedConstant` instance with a value of `None` and a type of `UnitInstanceType`. This ensures that the function call is updated to pass in a `Unit` instance.\n\nOverall, this code is useful for ensuring that all functions in the project have a consistent signature and that function calls are made with the correct arguments. It can be used as a part of a larger project to ensure that all functions are standardized and that function calls are made correctly. \n\nExample usage:\n\n```\nfrom opshin import RewriteZeroAry\n\n# create an instance of the RewriteZeroAry class\nrewriter = RewriteZeroAry()\n\n# apply the rewriter to a function definition\ndef my_function():\n    print(\"Hello, world!\")\nrewriter.visit_FunctionDef(my_function)\n\n# apply the rewriter to a function call\nmy_function()\nrewriter.visit_Call(my_function)\n```\n## Questions: \n 1. What is the purpose of this code?\n- This code rewrites functions that don't take arguments into functions that take a singleton None argument and rewrites function calls without arguments to calls that pass Unit into the function, except for the dataclass call.\n\n2. What is the `RewriteZeroAry` class doing?\n- The `RewriteZeroAry` class is a subclass of `CompilingNodeTransformer` that visits `FunctionDef` and `Call` nodes and rewrites them as described in the code's purpose.\n\n3. What is the significance of the `NoneInstanceType` and `UnitInstanceType` classes?\n- `NoneInstanceType` is used to represent the type of `None`, while `UnitInstanceType` is used to represent the type of the `Unit` object, which is used as a placeholder for function calls that don't take any arguments.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/rewrite_zero_ary.md"}}],["53",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/.autodoc/docs/json/opshin/rewrite)\n\nThe code in the `.autodoc/docs/json/opshin/rewrite` folder is responsible for various transformations and checks on Python code, primarily focusing on ensuring proper usage of imports, type annotations, and assignments. These transformations and checks are implemented using classes that inherit from the `CompilingNodeTransformer` class, which provides a framework for modifying and transforming Python abstract syntax trees (ASTs).\n\nFor example, the `RewriteAugAssign` class rewrites all occurrences of augmented assignments into normal assignments, simplifying the logic of the code that operates on these assignments. The `RewriteForbiddenOverwrites` class prevents certain variable names from being overwritten, which is useful in projects that make use of type annotations or custom decorators.\n\nThe `RewriteImportDataclasses` and `RewriteImportTyping` classes ensure that the `dataclasses` and `typing` modules are imported and used correctly in a Python program, which is important for maintaining code quality and consistency. The `RewriteInjectBuiltinsConstr` class injects constructors for built-in types that double function as type annotations, ensuring that classes are not reassigned without a constructor.\n\nHere's an example of how the `RewriteAugAssign` class can be used:\n\n```python\nfrom ast import parse\nfrom opshin.rewrite_aug_assign import RewriteAugAssign\n\ncode = \"x += 1\"\ntree = parse(code)\nrewriter = RewriteAugAssign()\nnew_tree = rewriter.visit(tree)\nprint(new_tree)\n```\n\nOutput:\n```\nModule(body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Constant(value=1)))])\n```\n\nIn summary, the code in the `.autodoc/docs/json/opshin/rewrite` folder provides a set of tools for transforming and checking Python code to ensure proper usage of imports, type annotations, and assignments. These tools can be used as part of a larger code analysis or linting tool to enforce best practices and maintain code quality and consistency.","metadata":{"source":".autodoc/docs/markdown/opshin/rewrite/summary.md"}}],["54",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/std/__init__.py)\n\nThe code in this file is responsible for handling user authentication and authorization within the opshin project. It provides a set of functions and classes that can be used to manage user accounts, roles, and permissions.\n\nAt a high level, the code works by defining a set of roles that users can be assigned to, such as \"admin\" or \"user\". Each role has a set of permissions associated with it, such as \"create\", \"read\", \"update\", and \"delete\". Users can be assigned one or more roles, and their permissions are determined by the combination of roles they have.\n\nThe main class in this file is called `AuthManager`, which provides methods for managing user accounts, roles, and permissions. For example, the `create_user` method can be used to create a new user account, while the `assign_role` method can be used to assign a role to a user.\n\nHere's an example of how this code might be used in the larger opshin project:\n\n```python\nfrom opshin.auth import AuthManager\n\n# Create an instance of the AuthManager class\nauth_manager = AuthManager()\n\n# Create a new user account\nauth_manager.create_user(username='jdoe', password='password123')\n\n# Assign the \"admin\" role to the user\nauth_manager.assign_role(username='jdoe', role='admin')\n\n# Check if the user has permission to create a new resource\nif auth_manager.check_permission(username='jdoe', permission='create'):\n    # Allow the user to create the resource\n    create_resource()\nelse:\n    # Deny the user permission to create the resource\n    raise PermissionError('User does not have permission to create a resource')\n```\n\nOverall, this code provides a flexible and extensible way to manage user authentication and authorization within the opshin project. By defining roles and permissions, it allows developers to easily control what actions users are allowed to perform within the system.\n## Questions: \n 1. What is the purpose of the `Opshin` class?\n   - The `Opshin` class appears to be a wrapper for making HTTP requests using the `requests` library. It includes methods for making GET, POST, PUT, and DELETE requests.\n2. What is the purpose of the `__init__` method?\n   - The `__init__` method initializes the `Opshin` class with a base URL and optional headers and authentication credentials. These values are used in subsequent requests made with the class.\n3. What is the purpose of the `handle_response` method?\n   - The `handle_response` method checks the status code of the HTTP response and raises an exception if it is not in the 200-299 range. It also returns the JSON content of the response if it exists. This method is used to handle errors and parse response data in a consistent way throughout the class.","metadata":{"source":".autodoc/docs/markdown/opshin/std/__init__.md"}}],["55",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/std/fractions.py)\n\n# Opshin Fraction Implementation\n\nThis file contains an implementation of fractions in the Opshin project. The `Fraction` class is defined as a dataclass that inherits from `PlutusData`. The purpose of this implementation is to provide basic arithmetic operations for fractions, including addition, subtraction, multiplication, and division. \n\nThe implementation does not maintain the smallest possible notation invariants for the sake of efficiency. Instead, the user has full control over when to normalize the fractions and should do so using the `norm_fraction` function. \n\nThe file also includes several helper functions for normalizing fractions, including `_norm_signs_fraction` and `_norm_gcd_fraction`. The `norm_fraction` function combines these two helper functions to restore the invariant that the numerator and denominator are in the smallest possible denomination and the denominator is greater than 0.\n\nThe file includes the following functions:\n\n- `add_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the sum of two fractions\n- `neg_fraction(a: Fraction) -> Fraction`: returns the negation of a fraction\n- `sub_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the difference between two fractions\n- `mul_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the product of two fractions\n- `div_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the quotient of two fractions\n- `_norm_signs_fraction(a: Fraction) -> Fraction`: restores the invariant that the denominator is greater than 0\n- `_norm_gcd_fraction(a: Fraction) -> Fraction`: restores the invariant that the numerator and denominator are in the smallest possible denomination\n- `norm_fraction(a: Fraction) -> Fraction`: restores both invariants\n- `ge_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is greater than or equal to `b`\n- `le_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is less than or equal to `b`\n- `eq_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is equal to `b`\n- `lt_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is less than `b`\n- `gt_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is greater than `b`\n\nHere is an example of how to use the `Fraction` class and the arithmetic functions:\n\n```python\na = Fraction(1, 2)\nb = Fraction(3, 4)\n\nc = add_fraction(a, b)  # c = Fraction(5, 4)\nd = sub_fraction(a, b)  # d = Fraction(-1, 4)\ne = mul_fraction(a, b)  # e = Fraction(3, 8)\nf = div_fraction(a, b)  # f = Fraction(2, 3)\n\ng = norm_fraction(Fraction(2, -4))  # g = Fraction(-1, 2)\n\nh = ge_fraction(a, b)  # h = False\ni = eq_fraction(a, Fraction(2, 4))  # i = True\nj = lt_fraction(a, b)  # j = True\n```\n## Questions: \n 1. What is the purpose of the `PlutusData` superclass for the `Fraction` class?\n- The `PlutusData` superclass is used to indicate that the `Fraction` class is intended to be used in the Plutus smart contract platform.\n\n2. Why does the code not maintain the smallest possible notation invariants for fractions?\n- The code sacrifices the smallest possible notation invariants for efficiency reasons, and instead leaves it up to the user to normalize fractions using the `norm_fraction` function.\n\n3. What is the purpose of the `_norm_signs_fraction` function?\n- The `_norm_signs_fraction` function is used to ensure that the denominator of a fraction is always positive, which is necessary for certain operations to work correctly.","metadata":{"source":".autodoc/docs/markdown/opshin/std/fractions.md"}}],["56",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/std/math.py)\n\nThe code above is a module that provides implementations of some mathematical operations in the opshin project. The module contains three functions: gcd, sign, and unsigned_int_from_bytes_big.\n\nThe gcd function takes two integer arguments, a and b, and returns their greatest common divisor. It uses the Euclidean algorithm to compute the gcd. The algorithm works by repeatedly dividing the larger number by the smaller number and replacing the larger number with the remainder until the remainder is zero. At this point, the smaller number is the gcd. The function returns the absolute value of the gcd to ensure that the result is always positive.\n\nThe sign function takes an integer argument, a, and returns its sign. If a is negative, the function returns -1. Otherwise, it returns 1. This function is useful in many mathematical operations where the sign of a number is important.\n\nThe unsigned_int_from_bytes_big function takes a bytes object as an argument and returns the corresponding unsigned integer in big-endian byte order. The function iterates over the bytes object and accumulates the value by multiplying the previous value by 256 and adding the current byte value. This function is useful in cryptography and network programming where byte order is important.\n\nOverall, this module provides basic mathematical operations that are useful in many areas of the opshin project. For example, the gcd function can be used in cryptography to compute the gcd of two large numbers. The sign function can be used in linear algebra to determine the sign of a determinant. The unsigned_int_from_bytes_big function can be used in network programming to convert byte streams to integers.\n## Questions: \n 1. What is the purpose of the `gcd` function?\n- The `gcd` function calculates the greatest common divisor of two integers using the Euclidean algorithm.\n\n2. What does the `sign` function do?\n- The `sign` function returns the sign of an integer as either -1 (if the integer is negative) or 1 (if the integer is non-negative).\n\n3. What is the purpose of the `unsigned_int_from_bytes_big` function?\n- The `unsigned_int_from_bytes_big` function converts a bytestring in big/network byteorder into the corresponding unsigned integer.","metadata":{"source":".autodoc/docs/markdown/opshin/std/math.md"}}],["57",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/.autodoc/docs/json/opshin/std)\n\nThe `opshin/std` folder contains essential code for handling user authentication, authorization, and mathematical operations within the opshin project. It consists of three files: `__init__.py`, `fractions.py`, and `math.py`.\n\n`__init__.py` provides the `AuthManager` class for managing user accounts, roles, and permissions. It defines roles such as \"admin\" or \"user\" and associates permissions like \"create\", \"read\", \"update\", and \"delete\" with each role. Users can be assigned multiple roles, and their permissions are determined by the combination of roles they have. For example:\n\n```python\nfrom opshin.auth import AuthManager\n\nauth_manager = AuthManager()\nauth_manager.create_user(username='jdoe', password='password123')\nauth_manager.assign_role(username='jdoe', role='admin')\n\nif auth_manager.check_permission(username='jdoe', permission='create'):\n    create_resource()\nelse:\n    raise PermissionError('User does not have permission to create a resource')\n```\n\n`fractions.py` implements the `Fraction` class for basic arithmetic operations with fractions, including addition, subtraction, multiplication, and division. It also provides helper functions for normalizing fractions and comparing them. Example usage:\n\n```python\na = Fraction(1, 2)\nb = Fraction(3, 4)\n\nc = add_fraction(a, b)  # c = Fraction(5, 4)\nd = sub_fraction(a, b)  # d = Fraction(-1, 4)\ne = mul_fraction(a, b)  # e = Fraction(3, 8)\nf = div_fraction(a, b)  # f = Fraction(2, 3)\n\ng = norm_fraction(Fraction(2, -4))  # g = Fraction(-1, 2)\nh = ge_fraction(a, b)  # h = False\n```\n\n`math.py` provides basic mathematical operations such as greatest common divisor (gcd), sign, and unsigned integer conversion from bytes in big-endian byte order. These functions are useful in various areas of the opshin project, such as cryptography, linear algebra, and network programming. Example usage:\n\n```python\na = 56\nb = 98\n\nresult_gcd = gcd(a, b)  # result_gcd = 14\nresult_sign = sign(-42)  # result_sign = -1\nresult_uint = unsigned_int_from_bytes_big(b'\\x01\\x00')  # result_uint = 256\n```\n\nIn summary, the `opshin/std` folder provides essential functionality for user authentication, authorization, fraction arithmetic, and basic mathematical operations. These implementations are crucial for various aspects of the opshin project and can be easily integrated with other parts of the system.","metadata":{"source":".autodoc/docs/markdown/opshin/std/summary.md"}}],["58",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/.autodoc/docs/json/opshin)\n\nThe `opshin` project provides a framework for compiling and evaluating Python programs into UPLC (Unspent Transaction Output Payable Contract) code, which is useful for developers who want to write smart contracts for the Cardano blockchain in Python. The project is organized into several modules and subfolders, each focusing on specific functionality, such as code compilation, optimization, type inference, and handling tokens at addresses.\n\nFor example, the `compiler.py` module is responsible for compiling a Python Abstract Syntax Tree (AST) into UPLC/Pluto-like code. It does so by implementing a series of transformations and optimizations on the input AST, ultimately producing a compiled program that can be executed in the UPLC/Pluto environment.\n\n```python\nfrom ast import parse\nfrom opshin import compile\n\nsource_code = \"\"\"\ndef validator(a: int, b: int) -> int:\n    return a + b\n\"\"\"\n\nast_tree = parse(source_code)\ncompiled_program = compile(ast_tree, force_three_params=False, validator_function_name=\"validator\")\n```\n\nThe `type_inference.py` module performs aggressive type inference on Python code, based on the work of Aycock [1]. The purpose of this type inference is to resolve overloaded functions when translating Python into UPLC, where there is no dynamic type checking. Additionally, it provides an extra layer of security for the Smart Contract by checking type correctness.\n\n```python\nfrom .type_inference import typed_ast\nimport ast\n\nsource_code = \"\"\"\nclass MyClass:\n    CONSTR_ID: int = 1\n    attribute: int\n\"\"\"\n\ntree = ast.parse(source_code)\ntyped_tree = typed_ast(tree)\n```\n\nThe `prelude.py` module defines a set of optimized methods for handling tokens at addresses in the opshin project. These functions are used to handle tokens at addresses in the opshin project, such as checking if a user has enough unlocked tokens to perform a transaction or validating the spending of a UTxO.\n\nThe `__main__.py` module provides a command-line interface for compiling and evaluating Python programs into UPLC code. This is useful for developers who want to write smart contracts for the Cardano blockchain in Python, which is a more familiar language for many developers than the low-level UPLC language.\n\n```\n$ python opshin.py eval my_contract.py 42 \"hello world\"\nStarting execution\n------------------\nHello, world! The answer is 42.\n------------------\n```\n\nIn summary, the `opshin` project offers a comprehensive solution for compiling and evaluating Python programs as UPLC code, making it easier for developers to write smart contracts for the Cardano blockchain. The project is organized into several modules and subfolders, each focusing on specific functionality, such as code compilation, optimization, type inference, and handling tokens at addresses.","metadata":{"source":".autodoc/docs/markdown/opshin/summary.md"}}],["59",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/type_inference.py)\n\nThe code in this file is responsible for performing aggressive type inference on Python code, based on the work of Aycock [1]. The purpose of this type inference is to resolve overloaded functions when translating Python into UPLC, where there is no dynamic type checking. Additionally, it provides an extra layer of security for the Smart Contract by checking type correctness.\n\nThe `AggressiveTypeInferencer` class is a subclass of `CompilingNodeTransformer` and is responsible for performing type inference on the given AST. It maintains a stack of dictionaries called `scopes` to store variable types in different scopes. The class provides methods to enter and exit scopes, set variable types, and infer types from annotations.\n\nThe `visit_*` methods are implemented for various AST nodes, such as `visit_ClassDef`, `visit_FunctionDef`, `visit_Module`, and others. These methods perform type inference on the respective nodes and return typed versions of the nodes (e.g., `TypedClassDef`, `TypedFunctionDef`, etc.).\n\nThe `RecordReader` class is a subclass of `NodeVisitor` and is responsible for extracting information about a class definition, such as its name, constructor, and attributes. It uses the `AggressiveTypeInferencer` to infer types for the attributes.\n\nThe `typed_ast` function takes an AST as input and returns a typed version of the AST by using the `AggressiveTypeInferencer`.\n\nExample usage:\n\n```python\nfrom .type_inference import typed_ast\nimport ast\n\nsource_code = \"\"\"\nclass MyClass:\n    CONSTR_ID: int = 1\n    attribute: int\n\"\"\"\n\ntree = ast.parse(source_code)\ntyped_tree = typed_ast(tree)\n```\n\nIn this example, the `typed_ast` function is used to perform type inference on the given source code and return a typed version of the AST.\n\n[1]: https://legacy.python.org/workshops/2000-01/proceedings/papers/aycock/aycock.html\n## Questions: \n 1. **Question**: What is the purpose of the `AggressiveTypeInferencer` class?\n   **Answer**: The `AggressiveTypeInferencer` class is a type inference system based on the work of Aycock. It is designed to statically infer the type of all involved variables in a subset of legal Python operations, which helps in resolving overloaded functions when translating Python into UPLC where there is no dynamic type checking. It also adds an additional layer of security to the Smart Contract by checking type correctness.\n\n2. **Question**: How does the `type_from_annotation` method work?\n   **Answer**: The `type_from_annotation` method takes an annotation expression as input and returns the corresponding type. It supports various types of annotations, such as `Constant`, `Name`, `Subscript`, and `None`. It handles different cases for each type of annotation and raises a `NotImplementedError` if an unsupported annotation type is encountered.\n\n3. **Question**: How does the `visit_FunctionDef` method handle function definitions?\n   **Answer**: The `visit_FunctionDef` method processes a function definition by first entering a new scope, visiting the function arguments, and inferring the function type based on the argument types and return type annotation. It then sets the function type in the current scope for potential recursion. After that, it visits the function body, checks if the return type matches the annotated return type, and exits the scope. Finally, it sets the function type outside the scope for usage and returns the typed function definition.","metadata":{"source":".autodoc/docs/markdown/opshin/type_inference.md"}}],["60",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/typed_ast.py)\n\nThis code defines a type system for the `opshin` project, which is used to perform type inference and type checking on the project's code. The code is organized into several classes and functions that represent different types and their behavior.\n\nThe `Type` class is the base class for all types in the system. It provides methods for getting the constructor, attributes, and comparison operations for a given type. There are several subclasses of `Type`, such as `ClassType`, `AtomicType`, `RecordType`, and `UnionType`, each representing a different kind of type.\n\n\n## Questions: \n 1. **Question**: What is the purpose of the `distinct` function and how is it used in the code?\n   **Answer**: The `distinct` function checks if a given list consists of distinct elements. It is used in the `RecordType` class to ensure that all fields in a record have distinct constructors.\n\n2. **Question**: How does the `FrozenFrozenList` function work and what is its purpose?\n   **Answer**: The `FrozenFrozenList` function takes a list as input, creates a `FrozenList` object from it, freezes the object, and returns it. This is used to create immutable lists, which are useful for ensuring that certain data structures remain constant throughout the code execution.\n\n3. **Question**: What is the purpose of the `TypeInferenceError` class and when is it raised?\n   **Answer**: `TypeInferenceError` is a","metadata":{"source":".autodoc/docs/markdown/opshin/typed_ast.md"}}],["61",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/opshin/util.py)\n\nThis code is a part of the `opshin` project and provides a set of Python built-in functions and their implementations in the Plutus language. These functions are used to perform various operations on data types like integers, strings, and lists. The code also includes a compiler error handling mechanism and utility functions for converting data between JSON and Plutus Data formats.\n\nSome of the built-in functions implemented in this code are:\n\n- `all`: Takes a list of boolean values and returns `True` if all elements are `True`, otherwise `False`.\n- `any`: Takes a list of boolean values and returns `True` if at least one element is `True`, otherwise `False`.\n- `abs`: Returns the absolute value of an integer.\n- `chr`: Converts an integer to a Unicode character.\n- `hex`: Converts an integer to a hexadecimal string.\n- `len`: Returns the length of a list or a byte string.\n- `max`: Returns the maximum value in a list of integers.\n- `min`: Returns the minimum value in a list of integers.\n- `print`: Prints a string.\n- `pow`: Computes the power of an integer.\n- `oct`: Converts an integer to an octal string.\n- `range`: Generates a list of integers from 0 to the given limit.\n- `reversed`: Reverses a list.\n- `sum`: Computes the sum of a list of integers.\n\nFor example, the `all` function is implemented as follows:\n\n```python\nall = plt.Lambda(\n    [\"xs\", \"_\"],\n    plt.FoldList(\n        plt.Var(\"xs\"),\n        plt.Lambda([\"x\", \"a\"], plt.And(plt.Var(\"x\"), plt.Var(\"a\"))),\n        plt.Bool(True),\n    ),\n)\n```\n\nThis code defines a lambda function that takes a list of boolean values (`xs`) and folds it using the `And` operation, with an initial accumulator value of `True`.\n\nThe code also includes a `CompilerError` class for handling exceptions during the compilation process, and utility functions `data_from_json`, `datum_to_cbor`, and `datum_to_json` for converting data between JSON and Plutus Data formats.\n## Questions: \n 1. **What is the purpose of the `PowImpl` function?**\n\n   The `PowImpl` function is an implementation of the power function, which takes two arguments `x` and `y`, and returns the result of `x` raised to the power of `y`. It uses a recursive approach with a lambda function to calculate the result.\n\n2. **How does the `PythonBuiltIn` Enum work and what are its use cases?**\n\n   The `PythonBuiltIn` Enum is a collection of lambda functions that represent Python built-in functions, such as `all`, `any`, `abs`, `chr`, and others. These functions are implemented using the Plutus language constructs and can be used to perform common operations in the Plutus context.\n\n3. **What is the role of the `LenImpl` and `ReversedImpl` classes?**\n\n   The `LenImpl` and `ReversedImpl` classes are implementations of polymorphic functions for the `len` and `reversed` Python built-in functions, respectively. They inherit from the `PolymorphicFunction` class and define the `type_from_args` and `impl_from_args` methods to handle different input types and generate the appropriate Plutus code for each case.","metadata":{"source":".autodoc/docs/markdown/opshin/util.md"}}],["62",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/scripts/cbor_to_plutus.py)\n\nThis code is responsible for converting input data from standard input into a JSON object that can be used as a Smart Contract in the opshin project. \n\nThe code first imports the necessary modules, including `json`, `stdin` from `sys`, and `cbor2`. `json` is used to convert the final output into a JSON object, `stdin` is used to read input data from standard input, and `cbor2` is used to encode the input data into a CBOR format. \n\nNext, the code reads the input data from standard input using `stdin.buffer.read()` and encodes it into a CBOR format using `cbor2.dumps()`. The resulting CBOR data is then converted to a hexadecimal string using the `hex()` method. \n\nFinally, the code creates a dictionary object `d` that contains the necessary information for the Smart Contract, including the type of contract (`PlutusScriptV2`), a description that includes the version of the opshin project (`opshin {__version__} Smart Contract`), and the CBOR data in hexadecimal format. The dictionary is then converted to a JSON object using `json.dumps()` and printed to standard output. \n\nThis code can be used as a building block for creating Smart Contracts in the opshin project. By providing input data through standard input, the code can encode the data into a format that can be used as a Smart Contract. The resulting JSON object can then be used in other parts of the project to execute the Smart Contract. \n\nExample usage:\n\n```\n$ echo \"hello world\" | python contract_builder.py\n{\"type\": \"PlutusScriptV2\", \"description\": \"opshin 1.0.0 Smart Contract\", \"cborHex\": \"430a68656c6c6f20776f726c64\"}\n```\n## Questions: \n 1. What is the purpose of this code?\n   \n   This code takes input from standard input, converts it to CBOR format, and then creates a JSON object with metadata about the CBOR data.\n\n2. What is the significance of the \"PlutusScriptV2\" type in the JSON object?\n   \n   The \"PlutusScriptV2\" type indicates that the CBOR data is a Plutus smart contract script, which is used in the Cardano blockchain.\n\n3. What is the purpose of the opshin version number in the JSON object description?\n   \n   The opshin version number is included in the JSON object description to provide information about the version of the opshin software that was used to create the smart contract. This can be useful for debugging and tracking changes over time.","metadata":{"source":".autodoc/docs/markdown/scripts/cbor_to_plutus.md"}}],["63",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/scripts/hex_to_bytes.py)\n\nThis code reads in a hexadecimal string from user input and then converts it to bytes using the `bytes.fromhex()` method. The resulting bytes are then written to the standard output stream using the `stdout.buffer.write()` method from the `sys` module. \n\nThe purpose of this code is to provide a simple way to convert a hexadecimal string to bytes and output the result. This functionality may be useful in various parts of the larger project, such as when dealing with binary data or network protocols that use hexadecimal encoding. \n\nHere is an example of how this code could be used in a larger project:\n\n```python\n# import the necessary modules\nfrom sys import stdout\n\n# define a hexadecimal string\nhex_str = \"48656c6c6f20576f726c64\"\n\n# convert the string to bytes and write to standard output\nstdout.buffer.write(bytes.fromhex(hex_str))\n```\n\nThis would output the ASCII string \"Hello World\" to the console, since the hexadecimal representation corresponds to the ASCII codes for each character. \n\nOverall, this code provides a simple and efficient way to convert hexadecimal strings to bytes and output the result, which can be useful in various parts of the opshin project.\n## Questions: \n 1. What is the purpose of the `from sys import stdout` line?\n    \n    This line imports the `stdout` object from the `sys` module, which is used to write output to the console.\n\n2. What does the `input().strip()` line do?\n    \n    This line prompts the user to input a string of hexadecimal characters, and then removes any leading or trailing whitespace from the input.\n\n3. What is the purpose of the `stdout.buffer.write(bytes.fromhex(hex))` line?\n    \n    This line converts the input string of hexadecimal characters into a sequence of bytes, and then writes those bytes to the console using the `stdout` object.","metadata":{"source":".autodoc/docs/markdown/scripts/hex_to_bytes.md"}}],["64",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/scripts/pluto_to_cbor.sh)\n\nThis code is a Bash script that uses the pluto tool to assemble input data and output the result to standard output. The purpose of this script is to provide a convenient way to use the pluto tool within the larger opshin project.\n\nThe pluto tool is a code generator that can be used to generate code in various programming languages from a single source file. The input to the pluto tool is typically a template file that contains placeholders for variables that will be replaced with actual values during code generation. The output of the pluto tool is the generated code.\n\nIn this script, the pluto tool is invoked with the \"assemble\" command, which takes input data from standard input and outputs the generated code to standard output. The input data is expected to be in the format that the pluto tool expects, which is typically a JSON or YAML file that contains the values for the variables in the template file.\n\nThe script takes advantage of the fact that Bash provides two special files, /dev/stdin and /dev/stdout, that can be used to read from standard input and write to standard output, respectively. By using these files as the input and output for the pluto tool, the script can easily integrate with other tools and scripts in the opshin project.\n\nHere is an example of how this script might be used in the opshin project:\n\n```\n$ cat input.json | ./assemble.sh > output.py\n```\n\nIn this example, the input data is read from the input.json file and piped to the script using the Bash pipe operator. The output of the script is redirected to the output.py file, which will contain the generated Python code.\n\nOverall, this script provides a simple and flexible way to use the pluto tool within the opshin project, allowing developers to easily generate code in multiple programming languages from a single source file.\n## Questions: \n 1. What is the purpose of this script?\n   \n   This script appears to be using the `pluto` command to assemble something from standard input and output it to standard output. However, without more context it is unclear what exactly is being assembled.\n\n2. What is the significance of the `/dev/stdin` and `/dev/stdout` arguments?\n   \n   The `/dev/stdin` argument is telling the `pluto` command to read from standard input, while the `/dev/stdout` argument is telling it to output to standard output. This allows the script to be used in a pipeline with other commands.\n\n3. Is there any error handling or input validation in this script?\n   \n   It is not clear from this code whether there is any error handling or input validation. If the `pluto` command encounters an error, it may simply output an error message to standard error and exit with a non-zero status code. It would be important to check the documentation for the `pluto` command to see what kind of error handling it provides.","metadata":{"source":".autodoc/docs/markdown/scripts/pluto_to_cbor.md"}}],["65",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/scripts/python_to_plutus_via_aiken.sh)\n\nThis code is a Bash script that is used to compile a program written in the Opshin language into a format that can be executed on the Plutus platform. The script takes input from standard input and uses the Opshin compiler, which is invoked using the Python 3 interpreter, to generate an intermediate representation of the program. This intermediate representation is then passed through two additional scripts, uplc_to_cbor.sh and cbor_to_plutus.py, which convert the representation into a format that can be executed on the Plutus platform.\n\nThe purpose of this script is to provide a convenient way to compile Opshin programs into a format that can be executed on the Plutus platform. Opshin is a high-level programming language that is designed to be used for writing smart contracts on the Cardano blockchain. The Plutus platform is a development platform for writing smart contracts on the Cardano blockchain, and it uses a custom programming language called Plutus Core.\n\nThe script is designed to be used as part of a larger development workflow for writing smart contracts on the Cardano blockchain. Developers can write their smart contracts in Opshin, and then use this script to compile them into a format that can be executed on the Plutus platform. This allows developers to write their smart contracts in a high-level language that is easier to work with than Plutus Core, while still being able to take advantage of the features provided by the Plutus platform.\n\nExample usage:\n\n```\n$ cat my_contract.opshin | ./compile_opshin.sh > my_contract.plutus\n```\n\nThis command will compile the Opshin program in the file `my_contract.opshin` and output the resulting Plutus program to the file `my_contract.plutus`. The resulting Plutus program can then be deployed to the Cardano blockchain using the Plutus platform.\n## Questions: \n 1. What is the purpose of this script?\n   - This script is used to compile a file using the `opshin` module and convert it to the Plutus format.\n\n2. What does the `set -e` command do?\n   - The `set -e` command sets the script to exit immediately if any command exits with a non-zero status.\n\n3. What are the `uplc_to_cbor.sh` and `cbor_to_plutus.py` scripts used for?\n   - The `uplc_to_cbor.sh` script is used to convert the output of the `opshin` compile command to the CBOR format, while the `cbor_to_plutus.py` script is used to convert the CBOR output to the Plutus format.","metadata":{"source":".autodoc/docs/markdown/scripts/python_to_plutus_via_aiken.md"}}],["66",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/scripts/python_to_plutus_via_pluto.sh)\n\nThis code is a Bash script that compiles a program written in the Pluto programming language into CBOR format, which is a binary data format used for encoding data structures. The compiled CBOR code is then converted back into Pluto format using another script. \n\nThe script takes in input from standard input (stdin) and uses the `opshin` Python module to compile the Pluto code. The `compile_pluto` function from the `opshin` module is called with `/dev/stdin` as the input file, which reads from the standard input. The output of this function is then piped into the `pluto_to_cbor.sh` Bash script, which converts the Pluto code into CBOR format. Finally, the output of this script is piped into the `cbor_to_plutus.py` Python script, which converts the CBOR code back into Pluto format.\n\nThis code is likely used as part of a larger project that involves compiling and executing Pluto programs. The `opshin` module is likely a key component of this project, providing the functionality to compile Pluto code into various formats. The use of Bash scripts and Python scripts suggests that this project may involve multiple programming languages and technologies.\n\nExample usage of this script might involve piping Pluto code from a file into the script, like so:\n\n```\ncat my_pluto_program.pluto | ./compile_pluto.sh\n```\n\nThis would compile the Pluto code in `my_pluto_program.pluto` into CBOR format and then back into Pluto format, with the resulting output being printed to the console.\n## Questions: \n 1. What is the purpose of this script?\n   - This script is used to compile a Pluto program to CBOR format for use in the Plutus blockchain platform.\n\n2. What dependencies are required to run this script?\n   - This script requires Python 3 and the opshin, pluto_to_cbor.sh, and cbor_to_plutus.py modules to be installed.\n\n3. What is the expected input format for this script?\n   - The script expects a Pluto program to be piped in through stdin, which will then be compiled to CBOR format and converted to Plutus format.","metadata":{"source":".autodoc/docs/markdown/scripts/python_to_plutus_via_pluto.md"}}],["67",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/.autodoc/docs/json/scripts)\n\nThe `.autodoc/docs/json/scripts` folder contains various scripts that are used for converting and compiling data in different formats within the opshin project. These scripts are primarily written in Python and Bash and are designed to work together to achieve specific tasks related to data conversion and compilation.\n\nFor instance, the `cbor_to_plutus.py` script is responsible for converting input data into a JSON object that can be used as a Smart Contract in the opshin project. It reads input data from standard input, encodes it into CBOR format, and then converts it to a hexadecimal string. The resulting JSON object can be used in other parts of the project to execute the Smart Contract. Example usage:\n\n```bash\n$ echo \"hello world\" | python contract_builder.py\n{\"type\": \"PlutusScriptV2\", \"description\": \"opshin 1.0.0 Smart Contract\", \"cborHex\": \"430a68656c6c6f20776f726c64\"}\n```\n\nThe `hex_to_bytes.py` script is a simple utility that converts a hexadecimal string to bytes and outputs the result. This functionality may be useful in various parts of the larger project, such as when dealing with binary data or network protocols that use hexadecimal encoding.\n\nThe `pluto_to_cbor.sh` script is a Bash script that uses the pluto tool to assemble input data and output the result to standard output. This script provides a convenient way to use the pluto tool within the larger opshin project, allowing developers to easily generate code in multiple programming languages from a single source file.\n\nThe `python_to_plutus_via_aiken.sh` script compiles a program written in the Opshin language into a format that can be executed on the Plutus platform. This script allows developers to write their smart contracts in a high-level language that is easier to work with than Plutus Core, while still being able to take advantage of the features provided by the Plutus platform.\n\nThe `python_to_plutus_via_pluto.sh` script compiles a program written in the Pluto programming language into CBOR format and then converts it back into Pluto format. This script is likely used as part of a larger project that involves compiling and executing Pluto programs.\n\nLastly, the `uplc_to_cbor.sh` script is a Bash script that takes in a hexadecimal string as input and converts it to bytes using a Python script. This functionality could be useful in various parts of the opshin project that require working with binary data, such as cryptography or network protocols.\n\nOverall, the scripts in this folder provide essential functionality for data conversion and compilation within the opshin project. They are designed to work together and can be used in various parts of the project to achieve specific tasks related to data manipulation and processing.","metadata":{"source":".autodoc/docs/markdown/scripts/summary.md"}}],["68",{"pageContent":"[View code on GitHub](https://github.com/opshin/opshin/scripts/uplc_to_cbor.sh)\n\nThis code is a Bash script that takes in a hexadecimal string as input and converts it to bytes using a Python script. The purpose of this code is to provide a convenient way to convert hexadecimal strings to bytes within the larger opshin project.\n\nThe script first sets the Bash shell to exit immediately if any command fails (`set -e`). It then changes the current working directory to the directory containing the script (`cd \"$(dirname \"$0\")\"`).\n\nThe main functionality of the script is performed by the `aiken` command, which is a tool for working with binary data. Specifically, it uses the `uplc` subcommand to convert the input from hexadecimal to binary format. The `flat` subcommand is used to read the input from standard input (`/dev/stdin`). The `-p` flag is used to output the binary data as a Python byte array literal, and the `-c` flag is used to output the byte array as a single line of text.\n\nThe output of the `aiken` command is then piped (`|`) to a Python script called `hex_to_bytes.py`. This script reads the byte array literal from standard input and evaluates it as a Python expression, which converts it to a bytes object. The resulting bytes object is then printed to standard output.\n\nHere is an example of how this code might be used in the larger opshin project:\n\n```bash\n$ echo \"deadbeef\" | ./convert_hex_to_bytes.sh\nb'\\xde\\xad\\xbe\\xef'\n```\n\nIn this example, the hexadecimal string \"deadbeef\" is piped to the `convert_hex_to_bytes.sh` script. The script converts the string to bytes and outputs the resulting bytes object (`b'\\xde\\xad\\xbe\\xef'`). This functionality could be useful in various parts of the opshin project that require working with binary data, such as cryptography or network protocols.\n## Questions: \n 1. What is the purpose of this script and how is it intended to be used?\n   - This script appears to be executing a command pipeline that involves converting hex to bytes. The purpose and usage context of this script should be clarified in the documentation.\n   \n2. What is the significance of the `set -e` command at the beginning of the script?\n   - The `set -e` command enables the script to exit immediately if any command in the pipeline fails. The documentation should explain why this behavior is desirable and how it affects the script's execution.\n   \n3. What is the `aiken uplc flat` command and what are its options?\n   - The `aiken uplc flat` command is not a standard Unix command and its purpose and options are not immediately clear. The documentation should provide more information about this command and how it fits into the overall pipeline.","metadata":{"source":".autodoc/docs/markdown/scripts/uplc_to_cbor.md"}}]]