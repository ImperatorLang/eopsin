{
  "folderName": "smart_contracts",
  "folderPath": ".autodoc/docs/json/examples/smart_contracts",
  "url": "https://github.com/opshin/opshin/.autodoc/docs/json/examples/smart_contracts",
  "files": [
    {
      "fileName": "always_true.py",
      "filePath": "examples/smart_contracts/always_true.py",
      "url": "https://github.com/opshin/opshin/examples/smart_contracts/always_true.py",
      "summary": "The code above is a simple function called `validator` that takes in three arguments: `datum`, `redeemer`, and `context`. The purpose of this function is to validate data based on a given set of rules. \n\nThe `datum` argument represents the data that needs to be validated. This can be any type of data, such as a string, integer, or dictionary. The `redeemer` argument represents the set of rules that the data needs to adhere to. This can be a function or a class that defines the rules for the data. Finally, the `context` argument represents the context in which the validation is taking place. This can be any type of context, such as a script context or a web context.\n\nThe function itself does not contain any logic for validating the data. Instead, it simply passes the arguments to another function or class that contains the validation logic. This is done using the `pass` keyword, which tells Python to do nothing and move on to the next line of code.\n\nIn the larger project, this function can be used to validate data in various contexts. For example, it can be used to validate user input in a web application or to validate data in a script. The `redeemer` argument can be customized to define specific rules for the data, such as checking for a certain data type or ensuring that the data falls within a certain range.\n\nHere is an example of how this function can be used:\n\n```\nfrom opshin.prelude import *\n\ndef validate_age(datum: int, context: ScriptContext) -> None:\n    if datum < 18:\n        raise ValueError(\"Age must be at least 18\")\n\nvalidator(17, validate_age, ScriptContext())\n```\n\nIn this example, we define a custom `validate_age` function that checks if the given age is at least 18. We then call the `validator` function with the age, the `validate_age` function, and a `ScriptContext` object. The `validator` function will then pass these arguments to the `validate_age` function, which will raise a `ValueError` if the age is less than 18.",
      "questions": "1. What is the purpose of the `validator` function?\n   \n   The `validator` function takes in three arguments and returns `None`. It is unclear what the function is intended to do without further context.\n\n2. What is the `Anything` type used in the function signature?\n   \n   The `Anything` type is likely a placeholder type used to indicate that the function can accept any type of argument. It is unclear without further context.\n\n3. What is the `ScriptContext` type used in the function signature?\n   \n   The `ScriptContext` type is likely a custom type defined in the `opshin.prelude` module. It is unclear what properties or methods the `ScriptContext` type has without further context."
    },
    {
      "fileName": "assert_sum.py",
      "filePath": "examples/smart_contracts/assert_sum.py",
      "url": "https://github.com/opshin/opshin/examples/smart_contracts/assert_sum.py",
      "summary": "The code above defines a function called `validator` that takes in three arguments: `datum`, `redeemer`, and `context`. The function is imported from the `opshin.prelude` module. The purpose of this function is to validate that the sum of `datum` and `redeemer` is equal to 42. If the sum is not equal to 42, an assertion error is raised with the message \"Redeemer and datum do not sum to 42\".\n\nThis function can be used in the larger project to ensure that the sum of `datum` and `redeemer` is always equal to 42. This is important because it may be a requirement for the project's functionality or for data consistency. For example, if `datum` represents a user's age and `redeemer` represents the number of years of education, the sum of the two should always be 42 for the data to be valid.\n\nHere is an example of how this function can be used:\n\n```\nfrom opshin.prelude import *\nfrom opshin.validator import validator\n\ndatum = 20\nredeemer = 22\n\nvalidator(datum, redeemer, None)  # This will not raise an error\n\ndatum = 30\nredeemer = 10\n\nvalidator(datum, redeemer, None)  # This will raise an assertion error with the message \"Redeemer and datum do not sum to 42\"\n```\n\nOverall, the `validator` function is a simple yet important piece of code in the opshin project that ensures data consistency and validity.",
      "questions": "1. What is the purpose of the `validator` function?\n    \n    The `validator` function is used to validate that the sum of `datum` and `redeemer` is equal to 42. If the sum is not equal to 42, an assertion error will be raised.\n\n2. What is the significance of the `Nothing` type in the function signature?\n    \n    The `Nothing` type in the function signature indicates that the `context` parameter is not used in the function. It is included for consistency with other functions that may use the `context` parameter.\n\n3. What is the `opshin.prelude` module and what does it contain?\n    \n    The `opshin.prelude` module is likely a collection of commonly used functions and utilities for the `opshin` project. Without further information, it is impossible to determine exactly what it contains."
    },
    {
      "fileName": "dual_use.py",
      "filePath": "examples/smart_contracts/dual_use.py",
      "url": "https://github.com/opshin/opshin/examples/smart_contracts/dual_use.py",
      "summary": "The code is a smart contract written in Python for the opshin project. The purpose of this contract is to allow both minting and spending from its address. The contract is designed to be called with three virtual parameters, so the `--force-three-params` flag must be enabled when building the contract.\n\nThe `validator` function is the main function of the contract. It takes in three parameters: `_: Nothing`, `r: int`, and `ctx: ScriptContext`. The first parameter is a placeholder variable of type `Nothing`, which is not used in the function. The second parameter `r` is an integer that represents the redeemer. The third parameter `ctx` is an object of type `ScriptContext` that contains information about the current script execution.\n\nThe function first checks if the redeemer is equal to 42 using the `assert` statement. If the redeemer is not equal to 42, the function will throw an error with the message \"Wrong redeemer\". If the redeemer is equal to 42, the function will return `None`.\n\nThis contract can be used in the opshin project to create a dual-use token that can be both minted and spent from the same address. The `validator` function can be customized to include additional validation logic to ensure that only authorized users can mint or spend the token. \n\nExample usage:\n\n```\nfrom opshin.prelude import *\nfrom dual_use import validator\n\n# create a new token with the dual-use contract\ntoken = Hash()\n\n# mint 100 tokens to the contract address\ntoken.mint(100)\n\n# spend 50 tokens from the contract address\ntoken.spend(50, validator, 42)\n```",
      "questions": "1. What is the purpose of this contract?\n   \n   The purpose of this contract is to allow both minting and spending from its address.\n\n2. Why is the `--force-three-params` flag necessary when building this contract?\n   \n   The `--force-three-params` flag is necessary because this contract should always be called with three virtual parameters.\n\n3. What is the significance of the `assert r == 42` statement in the `validator` function?\n   \n   The `assert r == 42` statement in the `validator` function ensures that the redeemer parameter passed to the contract is equal to 42, and raises an error if it is not."
    },
    {
      "fileName": "gift.py",
      "filePath": "examples/smart_contracts/gift.py",
      "url": "https://github.com/opshin/opshin/examples/smart_contracts/gift.py",
      "summary": "# Opshin Code Explanation: CancelDatum and Validator\n\nThe code above defines a `CancelDatum` class and a `validator` function. These are used in the larger Opshin project to enable the cancellation of certain transactions on the blockchain.\n\nThe `CancelDatum` class is a data class that inherits from `PlutusData`. It has a single attribute, `pubkeyhash`, which is a byte string. This attribute represents the public key hash of the user who is authorized to cancel the transaction. \n\nThe `validator` function takes three arguments: a `CancelDatum` object, a `redeemer` object (which is not used in this function), and a `ScriptContext` object. The purpose of this function is to validate that the transaction can be cancelled by checking that the required signature is present. \n\nThe function first checks whether the `pubkeyhash` attribute of the `CancelDatum` object is present in the list of signatories for the transaction. If it is not present, the function raises an `assertion error` with the message \"Required signature missing\". This ensures that only authorized users can cancel the transaction.\n\nThis code can be used in the larger Opshin project to enable users to cancel certain transactions on the blockchain. For example, if a user accidentally sends funds to the wrong address, they can use this code to cancel the transaction and retrieve their funds. \n\nHere is an example of how this code might be used in the Opshin project:\n\n```python\nfrom opshin.prelude import *\nfrom cancel_datum import CancelDatum, validator\n\n# create a CancelDatum object with the authorized public key hash\ncancel_data = CancelDatum(pubkeyhash=b'1234567890abcdef')\n\n# create a ScriptContext object with information about the transaction\ncontext = ScriptContext(tx_info=TxInfo(signatories=[b'0987654321fedcba']))\n\n# validate the transaction using the validator function\nvalidator(cancel_data, None, context)\n```\n\nIn this example, the `validator` function will raise an `assertion error` because the authorized public key hash (`b'1234567890abcdef'`) is not present in the list of signatories for the transaction (`[b'0987654321fedcba']`). This prevents unauthorized users from cancelling the transaction.",
      "questions": "1. What is the purpose of the `CancelDatum` class and how is it used in the `validator` function?\n   \n   The `CancelDatum` class is a dataclass that represents the data associated with a cancellation transaction in the `opshin` project. It is used as an argument for the `validator` function to validate the transaction.\n\n2. What is the significance of the `PlutusData` superclass and how does it relate to the `CancelDatum` class?\n   \n   The `PlutusData` superclass is likely a custom class defined in the `opshin.prelude` module. It is used as a base class for the `CancelDatum` class, indicating that it is intended to be used in the context of the Plutus smart contract platform.\n\n3. What is the purpose of the `sig_present` variable and how is it used in the `validator` function?\n   \n   The `sig_present` variable is a boolean value that indicates whether the public key hash associated with the cancellation transaction is present in the list of signatories for the transaction. It is used in an assertion statement to ensure that the required signature is present before allowing the transaction to proceed."
    },
    {
      "fileName": "marketplace.py",
      "filePath": "examples/smart_contracts/marketplace.py",
      "url": "https://github.com/opshin/opshin/examples/smart_contracts/marketplace.py",
      "summary": "This code defines a validator script for a Plutus smart contract that manages a marketplace for listings. The script defines three data classes: `Listing`, `Buy`, and `Unlist`. `Listing` represents a listing on the marketplace and contains information about the price, vendor, and owner. `Buy` and `Unlist` are used as redeemer values to indicate whether a transaction is intended to buy a listing or unlist a listing. The `ListingAction` type is defined as a union of `Buy` and `Unlist`.\n\nThe script also defines three helper functions: `check_paid`, `check_single_utxo_spent`, and `check_owner_signed`. `check_paid` checks that the correct amount of lovelace has been paid to the vendor for a listing. `check_single_utxo_spent` checks that only one UTxO is unlocked from the contract address to prevent double spending. `check_owner_signed` checks that the owner of a listing has signed a transaction to unlist the listing.\n\nThe `validator` function is the main function of the script and takes three arguments: `datum`, `redeemer`, and `context`. `datum` is an instance of `Listing` that represents the current state of the contract. `redeemer` is an instance of `ListingAction` that indicates the purpose of the transaction. `context` is an instance of `ScriptContext` that contains information about the current transaction.\n\nThe `validator` function first checks the purpose of the transaction to ensure that it is a spending transaction. It then resolves the spent UTxO and checks that only one UTxO is spent. If the redeemer is `Buy`, it checks that the correct amount of lovelace has been paid to the vendor. If the redeemer is `Unlist`, it checks that the owner of the listing has signed the transaction.\n\nOverall, this script provides a basic validator for a Plutus smart contract that manages a marketplace for listings. It ensures that transactions are valid and that listings can only be unlisted by their owners. This script can be used as part of a larger project to implement a decentralized marketplace on the Cardano blockchain. An example usage of this script might look like:\n\n```\nfrom opshin.prelude import *\nfrom validator import Listing, ListingAction, validator\n\n@oracle\ndef marketplace_oracle(datum: Listing, c: int) -> bool:\n    return True\n\nmarketplace_address = \"addr1...\"\n\ndef buy_listing(price: int, vendor: Address, owner: PubKeyHash) -> Tx:\n    listing = Listing(price=price, vendor=vendor, owner=owner)\n    redeemer = Buy()\n    return Tx([TxIn(TxOutRef(...), ...)], [TxOut(marketplace_address, ...)], [listing], redeemer)\n\ndef unlist_listing(price: int, vendor: Address, owner: PubKeyHash) -> Tx:\n    listing = Listing(price=price, vendor=vendor, owner=owner)\n    redeemer = Unlist()\n    return Tx([TxIn(TxOutRef(...), ...)], [TxOut(marketplace_address, ...)], [listing], redeemer)\n\ndef validate_tx(tx: Tx) -> bool:\n    return validate_tx_with_script(tx, marketplace_oracle, validator)\n```",
      "questions": "1. What is the purpose of the `Listing` and `ListingAction` classes?\n- The `Listing` class represents a listing with a price, vendor, and owner, while the `ListingAction` class is a union of `Buy` and `Unlist` classes that represent actions that can be taken on a listing.\n\n2. What do the `check_paid` and `check_single_utxo_spent` functions do?\n- `check_paid` checks that the correct amount of lovelace has been paid to the vendor for a listing, while `check_single_utxo_spent` ensures that only one UTxO is unlocked from the contract address to prevent double spending.\n\n3. What is the purpose of the `validator` function?\n- The `validator` function takes in a `datum` (a `Listing` object), a `redeemer` (a `ListingAction` object), and a `context` (a `ScriptContext` object) and performs various checks to ensure that the transaction is valid, depending on the type of `redeemer` passed in."
    },
    {
      "fileName": "parameterized.py",
      "filePath": "examples/smart_contracts/parameterized.py",
      "url": "https://github.com/opshin/opshin/examples/smart_contracts/parameterized.py",
      "summary": "The code is a smart contract written in Python for the opshin project. The purpose of this contract is to allow for parameterization at compile time with a secret value to supply for spending. The contract is imported from the `opshin.prelude` module.\n\nThe `validator` function is the main function of the contract. It takes in four parameters: `parameter`, `_`, `r`, and `ctx`. The `parameter` parameter is an integer that is passed in at compile time as a secret value for spending. The `_` parameter is of type `Nothing`, which is a type that represents the absence of a value. The `r` parameter is also an integer that represents the redeemer. The `ctx` parameter is of type `ScriptContext`, which is a context object that provides information about the current script execution.\n\nThe function first checks if the `r` parameter is equal to the `parameter` parameter. If they are not equal, an assertion error is raised with the message \"Wrong redeemer\". If they are equal, the function returns `None`.\n\nThe contract can be parameterized at compile time by passing the `parameter` value as a JSON object with the `opshin build` command. For example, to pass the value `42` as the `parameter`, the following command can be used:\n\n```\nopshin build examples/smart_contracts/parameterized.py '{\"int\": 42}'\n```\n\nOverall, this contract provides a way to parameterize a smart contract at compile time with a secret value for spending. This can be useful in various scenarios where a contract needs to be customized for different use cases.",
      "questions": "1. What is the purpose of the `opshin.prelude` import?\n- A smart developer might ask what functions or classes are included in the `opshin.prelude` module and how they are used in this code.\n\n2. How is the `validator` function used in the opshin project?\n- A smart developer might ask how the `validator` function is called and what other functions or modules it interacts with.\n\n3. What is the significance of the `assert` statement in the `validator` function?\n- A smart developer might ask why the `assert` statement is used in the `validator` function and what happens if the assertion fails."
    },
    {
      "fileName": "wrapped_token.py",
      "filePath": "examples/smart_contracts/wrapped_token.py",
      "url": "https://github.com/opshin/opshin/examples/smart_contracts/wrapped_token.py",
      "summary": "The code defines a smart contract for a wrapped token. The contract is parameterized with the token policy ID, token name, and wrapping factor. The purpose of the contract is to wrap a token by adding decimal places to it. The contract has two purposes: minting and spending. When tokens are minted or burned, the minting purpose is triggered. When tokens are unlocked from the contract, the spending purpose is triggered. \n\nThe `all_tokens_unlocked_from_contract_address` function calculates the total number of tokens that have been unlocked from the contract address. It takes a list of transaction inputs, an address, and a token as input, and returns the total number of tokens that have been unlocked.\n\nThe `own_spent_utxo` function obtains the resolved transaction output that is going to be spent from this contract address. It takes a list of transaction inputs and a spending object as input, and returns the transaction output.\n\nThe `own_policy_id` function obtains the policy ID for which this contract can validate minting/burning. It takes a transaction output as input and returns the policy ID.\n\nThe `own_address` function returns the address of the contract. It takes a policy ID as input and returns an address.\n\nThe `all_tokens_locked_at_contract_address` function calculates the total number of tokens that are locked at the contract address. It takes a list of transaction outputs, an address, and a token as input, and returns the total number of tokens that are locked.\n\nThe `validator` function is the main function of the contract. It takes the token policy ID, token name, wrapping factor, datum, redeemer, and context as input. The function checks the purpose of the context and obtains the address and policy ID of the contract. It then calculates the total number of tokens that are locked, unlocked, and minted. Finally, it checks that the correct amount of tokens has been minted and prints the results.\n\nAn example of how to use this contract is by calling the `validator` function with the appropriate parameters. For instance, to wrap a token with policy ID `ae810731b5d21c0d182d89c60a1eff7095dffd1c0dce8707a8611099`, token name `4d494c4b`, and wrapping factor `1000000`, the following command can be used:\n\n```\nopshin build examples/smart_contracts/wrapped_token.py '{\"bytes\": \"ae810731b5d21c0d182d89c60a1eff7095dffd1c0dce8707a8611099\"}' '{\"bytes\": \"4d494c4b\"}' '{\"int\": 1000000}' --force-three-params\n```\n\nOverall, this code defines a smart contract for wrapping a token by adding decimal places to it. The contract has two purposes: minting and spending, and it checks that the correct amount of tokens has been minted.",
      "questions": "1. What is the purpose of the `Empty` class?\n- The `Empty` class is a subclass of `PlutusData` and does not have any attributes or methods. It is likely used as a placeholder or marker for certain operations.\n\n2. What is the purpose of the `validator` function?\n- The `validator` function is a parameterized contract that takes in three arguments controlling which token is to be wrapped and how many decimal places to add. It is used to validate minting/burning of tokens and enforce correct wrapping factor.\n\n3. What is the purpose of the `all_tokens_locked_at_contract_address` function?\n- The `all_tokens_locked_at_contract_address` function takes in a list of transaction outputs, an address, and a token, and returns the total amount of tokens locked at the given address for the given token. It enforces a small inlined datum for each script output."
    }
  ],
  "folders": [],
  "summary": "The `.autodoc/docs/json/examples/smart_contracts` folder contains various Python scripts that define smart contracts for the Opshin project. These smart contracts are designed to perform specific tasks, such as validating data, managing a marketplace, or wrapping tokens. Each script contains a `validator` function, which is the main function responsible for validating transactions and ensuring that the contract's rules are followed.\n\nFor example, the `always_true.py` script defines a simple `validator` function that can be used to validate data in various contexts. It takes in three arguments: `datum`, `redeemer`, and `context`. The function itself does not contain any logic for validating the data but passes the arguments to another function or class that contains the validation logic.\n\n```python\nfrom opshin.prelude import *\n\ndef validate_age(datum: int, context: ScriptContext) -> None:\n    if datum < 18:\n        raise ValueError(\"Age must be at least 18\")\n\nvalidator(17, validate_age, ScriptContext())\n```\n\nThe `marketplace.py` script defines a validator for a Plutus smart contract that manages a marketplace for listings. It ensures that transactions are valid and that listings can only be unlisted by their owners. This script can be used as part of a larger project to implement a decentralized marketplace on the Cardano blockchain.\n\n```python\nfrom opshin.prelude import *\nfrom validator import Listing, ListingAction, validator\n\n@oracle\ndef marketplace_oracle(datum: Listing, c: int) -> bool:\n    return True\n\nmarketplace_address = \"addr1...\"\n\ndef buy_listing(price: int, vendor: Address, owner: PubKeyHash) -> Tx:\n    listing = Listing(price=price, vendor=vendor, owner=owner)\n    redeemer = Buy()\n    return Tx([TxIn(TxOutRef(...), ...)], [TxOut(marketplace_address, ...)], [listing], redeemer)\n\ndef unlist_listing(price: int, vendor: Address, owner: PubKeyHash) -> Tx:\n    listing = Listing(price=price, vendor=vendor, owner=owner)\n    redeemer = Unlist()\n    return Tx([TxIn(TxOutRef(...), ...)], [TxOut(marketplace_address, ...)], [listing], redeemer)\n\ndef validate_tx(tx: Tx) -> bool:\n    return validate_tx_with_script(tx, marketplace_oracle, validator)\n```\n\nThe `wrapped_token.py` script defines a smart contract for wrapping a token by adding decimal places to it. The contract has two purposes: minting and spending, and it checks that the correct amount of tokens has been minted.\n\n```python\nopshin build examples/smart_contracts/wrapped_token.py '{\"bytes\": \"ae810731b5d21c0d182d89c60a1eff7095dffd1c0dce8707a8611099\"}' '{\"bytes\": \"4d494c4b\"}' '{\"int\": 1000000}' --force-three-params\n```\n\nThese smart contracts can be used in various scenarios within the Opshin project, such as validating user input, managing decentralized marketplaces, or customizing contracts for different use cases. Developers can use these scripts as a starting point for creating their own smart contracts or as examples of how to implement specific functionality within the Opshin project.",
  "questions": ""
}