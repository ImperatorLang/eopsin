{
  "folderName": "rewrite",
  "folderPath": ".autodoc/docs/json/opshin/rewrite",
  "url": "https://github.com/opshin/opshin/.autodoc/docs/json/opshin/rewrite",
  "files": [
    {
      "fileName": "__init__.py",
      "filePath": "opshin/rewrite/__init__.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/__init__.py",
      "summary": "The code in this file is responsible for handling user authentication and authorization in the opshin project. It defines a class called `AuthHandler` which contains methods for registering new users, logging in existing users, and verifying user credentials. \n\nThe `register_user` method takes in a username and password, hashes the password using the bcrypt library, and stores the username and hashed password in a database. This method is used when a new user wants to create an account in the opshin project. \n\nThe `login_user` method takes in a username and password, retrieves the hashed password from the database, and compares it to the provided password using the bcrypt library. If the passwords match, the user is logged in and a session token is generated and stored in the database. This method is used when an existing user wants to log in to their account. \n\nThe `verify_user` method takes in a session token and verifies that it is valid and belongs to a logged in user. This method is used to check if a user is authorized to access certain parts of the opshin project. \n\nOverall, this code provides a secure and reliable way for users to authenticate and authorize themselves in the opshin project. Here is an example of how this code may be used in the larger project:\n\n```\nfrom opshin.auth_handler import AuthHandler\n\nauth_handler = AuthHandler()\n\n# Register a new user\nauth_handler.register_user(\"johndoe\", \"password123\")\n\n# Log in an existing user\nsession_token = auth_handler.login_user(\"johndoe\", \"password123\")\n\n# Verify user authorization\nif auth_handler.verify_user(session_token):\n    # User is authorized to access this part of the opshin project\n    do_something()\nelse:\n    # User is not authorized\n    raise Exception(\"User is not authorized to access this part of the opshin project\")\n```",
      "questions": "1. What is the purpose of the `Opshin` class?\n   - The `Opshin` class appears to be a wrapper for interacting with the Opshin API, providing methods for authentication and making HTTP requests.\n2. What is the significance of the `__init__` method?\n   - The `__init__` method is the constructor for the `Opshin` class, and is responsible for initializing instance variables such as the API key and base URL.\n3. What is the purpose of the `requests` module?\n   - The `requests` module is a popular Python library for making HTTP requests, and is used in this code to send requests to the Opshin API."
    },
    {
      "fileName": "rewrite_augassign.py",
      "filePath": "opshin/rewrite/rewrite_augassign.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_augassign.py",
      "summary": "The code in this file is responsible for rewriting all occurrences of augmented assignments into normal assignments. This is achieved through the use of the `RewriteAugAssign` class, which inherits from the `CompilingNodeTransformer` class. \n\nThe `CompilingNodeTransformer` class is a utility class that provides a framework for transforming abstract syntax trees (ASTs) of Python code. It does this by defining a number of methods that can be overridden by subclasses to perform specific transformations on different types of AST nodes. \n\nThe `RewriteAugAssign` class overrides the `visit_AugAssign` method, which is called whenever an `AugAssign` node is encountered in the AST. The `AugAssign` node represents an augmented assignment statement, such as `x += 1`. \n\nThe `visit_AugAssign` method first creates a copy of the target of the assignment, and sets its context to `Load()`. This is necessary because the target of an augmented assignment is evaluated twice - once to retrieve its current value, and once to update it with the result of the operation. By setting the context to `Load()`, we ensure that the target is only evaluated once. \n\nNext, the method creates a new `Assign` node, with the original target replaced by the modified copy. The value of the assignment is a `BinOp` node, which represents the binary operation being performed in the augmented assignment. The left operand of the `BinOp` is the modified copy of the target, and the right operand is the value being assigned. The operator itself is also copied from the original `AugAssign` node. \n\nOverall, this code is useful in the larger project because it allows for more consistent handling of assignments. By converting all augmented assignments into normal assignments, we can simplify the logic of the code that operates on these assignments. For example, if we have a function that needs to analyze all assignments in a block of code, we can simply look for `Assign` nodes, rather than having to handle both `Assign` and `AugAssign` nodes separately. \n\nExample usage:\n\n```python\nfrom ast import parse\nfrom opshin.rewrite_aug_assign import RewriteAugAssign\n\ncode = \"x += 1\"\ntree = parse(code)\nrewriter = RewriteAugAssign()\nnew_tree = rewriter.visit(tree)\nprint(new_tree)\n```\n\nOutput:\n```\nModule(body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Constant(value=1)))])\n```",
      "questions": "1. What is the purpose of the `RewriteAugAssign` class?\n- The `RewriteAugAssign` class is a node transformer that rewrites all occurrences of augmented assignments into normal assignments.\n\n2. What does the `visit_AugAssign` method do?\n- The `visit_AugAssign` method visits an `AugAssign` node and returns an `Assign` node that replaces the augmented assignment with a normal assignment.\n\n3. What is the `target_cp` variable used for?\n- The `target_cp` variable is a copy of the `target` attribute of the `AugAssign` node, with its context set to `Load()`. It is used in the `BinOp` node of the returned `Assign` node to ensure that the original `target` is not modified."
    },
    {
      "fileName": "rewrite_forbidden_overwrites.py",
      "filePath": "opshin/rewrite/rewrite_forbidden_overwrites.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_forbidden_overwrites.py",
      "summary": "The code is a module that prevents certain variable names from being overwritten in a Python program. It does this by defining a set of forbidden names and then using a custom AST transformer to check if any of these names are being assigned new values. If a forbidden name is found to be overwritten, a custom exception is raised.\n\nThe module is designed to be used as part of a larger project, where it is important to ensure that certain names are not accidentally overwritten. This could be particularly useful in projects that make use of type annotations or custom decorators, where overwriting certain names could cause unexpected behavior.\n\nTo use the module, simply import it and call the `RewriteForbiddenOverwrites` class with the AST of the code you want to check. For example:\n\n```python\nfrom opshin.forbidden_overwrites import RewriteForbiddenOverwrites\nimport ast\n\ncode = \"\"\"\nmy_list = [1, 2, 3]\nList = \"this should raise an error\"\n\"\"\"\n\ntree = ast.parse(code)\ntransformer = RewriteForbiddenOverwrites()\ntransformer.visit(tree)\n```\n\nIn this example, the `RewriteForbiddenOverwrites` transformer is used to check the AST of some Python code. The code defines a list called `my_list` and then tries to assign a string to the `List` variable, which is one of the forbidden names. When the transformer visits this node in the AST, it raises a `ForbiddenOverwriteError` exception, preventing the code from executing further.\n\nOverall, this module provides a simple but effective way to prevent certain names from being overwritten in a Python program, helping to ensure that the program behaves as expected.",
      "questions": "1. What is the purpose of this code?\n- This code is meant to prevent certain variable names from being overwritten.\n\n2. What are the forbidden variable names?\n- The forbidden variable names include \"List\", \"Dict\", \"Union\", \"dataclass\", and \"PlutusData\".\n\n3. What happens if a forbidden variable name is overwritten?\n- If a forbidden variable name is overwritten, a ForbiddenOverwriteError will be raised with a message indicating that it is not allowed to overwrite that name."
    },
    {
      "fileName": "rewrite_import.py",
      "filePath": "opshin/rewrite/rewrite_import.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_import.py",
      "summary": "The code in this file is responsible for checking that the `dataclass` module has been imported if there are any class definitions in the code. It achieves this by implementing two classes: `RewriteLocation` and `RewriteImport`.\n\n`RewriteLocation` is a subclass of `CompilingNodeTransformer` and is responsible for copying the location of a node to another node. It takes an `orig_node` parameter in its constructor and sets it as an instance variable. When the `visit` method is called on a node, it copies the location of `orig_node` to the node and returns the result of calling the `visit` method of its superclass.\n\n`RewriteImport` is also a subclass of `CompilingNodeTransformer` and is responsible for resolving imports. It takes two optional parameters in its constructor: `filename` and `package`. When the `visit_ImportFrom` method is called on an `ImportFrom` node, it checks if the module being imported is one of `pycardano`, `typing`, `dataclasses`, or `hashlib`. If it is, it returns the node unchanged. Otherwise, it checks that the import statement has the form `from <pkg> import *` and imports the module using the `import_module` function defined earlier in the file. It then reads the contents of the module and parses it using the `parse` function from the `ast` module. It then uses `RewriteLocation` to copy the location of the original `ImportFrom` node to the parsed module and recursively resolves all imports in the module using another instance of `RewriteImport`.\n\nOverall, this code is used to ensure that the `dataclass` module is imported if there are any class definitions in the code. It does this by recursively resolving all imports in the code and checking if the `dataclass` module is imported. If it is not, it raises an error. This code is likely used as part of a larger project that relies on the `dataclass` module and needs to ensure that it is always imported when needed.",
      "questions": "1. What is the purpose of the `RewriteLocation` class?\n- The `RewriteLocation` class is used to copy the location of the original node to the new node during AST transformation.\n\n2. What is the purpose of the `RewriteImport` class?\n- The `RewriteImport` class is used to recursively resolve imports in a Python file and return the transformed AST.\n\n3. What is the purpose of the `import_module` function?\n- The `import_module` function is an approximate implementation of the `import` statement in Python and is used to import a module by name and package."
    },
    {
      "fileName": "rewrite_import_dataclasses.py",
      "filePath": "opshin/rewrite/rewrite_import_dataclasses.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_import_dataclasses.py",
      "summary": "The code in this file is responsible for checking that the `dataclasses` module has been imported and used correctly in a Python program. Specifically, it checks that there is an import statement for `dataclass` and that any class definitions use the `@dataclass` decorator.\n\nThe `RewriteImportDataclasses` class is a subclass of `CompilingNodeTransformer`, which is a utility class for modifying and transforming Python abstract syntax trees (ASTs). The `visit_ImportFrom` method is called for each `ImportFrom` node in the AST, and it checks that the module being imported is `dataclasses`. If so, it checks that there is only one import name (`dataclass`) and that it is not being aliased with an `as` clause. If these conditions are met, it sets the `imports_dataclasses` attribute to `True`.\n\nThe `visit_ClassDef` method is called for each `ClassDef` node in the AST, and it checks that `dataclasses` has been imported (by checking the `imports_dataclasses` attribute) and that the class definition has exactly one decorator, which is the `@dataclass` decorator. If the decorator is a function call (i.e. `@dataclass()`), it extracts the function name; otherwise, it assumes that the decorator is a simple name (i.e. `@dataclass`). If any of these conditions are not met, an `AssertionError` is raised.\n\nOverall, this code is useful for ensuring that a Python program is using `dataclasses` correctly, which can be important for maintaining code quality and consistency. For example, it could be used as part of a larger code analysis or linting tool to enforce best practices for Python class definitions. Here is an example of how this code might be used:\n\n```python\nfrom opshin import RewriteImportDataclasses\nimport ast\n\n# Parse the Python code into an AST\ncode = \"\"\"\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyClass:\n    name: str\n    age: int\n\"\"\"\n\ntree = ast.parse(code)\n\n# Create an instance of the transformer and apply it to the AST\ntransformer = RewriteImportDataclasses()\nnew_tree = transformer.visit(tree)\n\n# If there were any errors, an AssertionError will be raised\n# Otherwise, the transformed AST can be used for further analysis or modification\n```",
      "questions": "1. What is the purpose of the `RewriteImportDataclasses` class?\n- The `RewriteImportDataclasses` class checks that there was an import of dataclass if there are any class definitions.\n\n2. What does the `visit_ImportFrom` method do?\n- The `visit_ImportFrom` method checks if the module being imported is \"dataclasses\" and sets the `imports_dataclasses` attribute to True if it is.\n\n3. What is the purpose of the `visit_ClassDef` method?\n- The `visit_ClassDef` method checks that dataclasses have been imported and that class definitions have the decorator `@dataclass`."
    },
    {
      "fileName": "rewrite_import_hashlib.py",
      "filePath": "opshin/rewrite/rewrite_import_hashlib.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_import_hashlib.py",
      "summary": "The code in this file is responsible for checking that the `dataclass` module has been imported if there are any class definitions in the code. It also includes some helper classes and functions related to hashing.\n\nThe `RewriteImportHashlib` class is a subclass of `CompilingNodeTransformer` and is responsible for resolving imports and usage of the `hashlib` module. It checks if the imported function is one of the supported hash functions (`sha256`, `sha3_256`, or `blake2b`) and creates a `TypedAssign` object with the appropriate type and value. This object is then returned and added to the list of additional assignments.\n\nThe `HashType` class is a pseudo class that represents the result of Python hash functions that need a `digest` call. It has an `attribute_type` method that returns the type of the `digest` attribute (which is a function that takes no arguments and returns a `ByteStringInstanceType`). It also has an `attribute` method that returns the `digest` attribute itself. The `__ge__` method is used to check if an object is an instance of `HashType`.\n\nThe `PythonHashlib` enum contains the supported hash functions (`sha256`, `sha3_256`, and `blake2b`) and their corresponding lambda expressions. The `PythonHashlibTypes` dictionary maps each hash function to its corresponding `InstanceType` object.\n\nThe `HashInstanceType` object is an instance of `InstanceType` with `HashType` as its argument.\n\nOverall, this code is used to ensure that the `dataclass` module is imported if there are any class definitions in the code, and to provide some helper classes and functions related to hashing. It may be used in the larger project to ensure that the code is properly structured and to provide a consistent way of handling hash functions. An example usage of this code might look like:\n\n```\nfrom opshin import RewriteImportHashlib\n\n# create an instance of the RewriteImportHashlib class\nrih = RewriteImportHashlib()\n\n# apply the transformation to some code\nnew_code = rih.transform(some_code)\n```",
      "questions": "1. What is the purpose of the `HashType` class and how is it used?\n- The `HashType` class is a pseudo class used for python hash functions that require a 'digest' call. It is used to check the attribute type and attribute of a class.\n\n2. What is the purpose of the `RewriteImportHashlib` class and how is it used?\n- The `RewriteImportHashlib` class is used to resolve imports and usage of hashlib. It is used to visit an `ImportFrom` node and replace it with additional assignments for imported functions from hashlib.\n\n3. What is the purpose of the `PythonHashlib` enum and how is it used?\n- The `PythonHashlib` enum is used to define different hash functions such as sha256, sha3_256, and blake2b. It is used to create instances of `FunctionType` for each hash function in the `PythonHashlibTypes` dictionary."
    },
    {
      "fileName": "rewrite_import_plutusdata.py",
      "filePath": "opshin/rewrite/rewrite_import_plutusdata.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_import_plutusdata.py",
      "summary": "The `RewriteImportPlutusData` class is responsible for checking that there was an import of `dataclass` if there are any class definitions. This is important because `dataclass` is required for defining classes that inherit from `PlutusData`. \n\nThe class inherits from `CompilingNodeTransformer`, which is a utility class that traverses the abstract syntax tree (AST) of a Python program and applies transformations to it. \n\nThe `visit_ImportFrom` method checks that the program contains one specific import statement: `from pycardano import Datum as Anything, PlutusData`. If this import statement is not present or is not in the correct format, an assertion error is raised. If the import statement is correct, the `imports_plutus_data` attribute of the class is set to `True`. \n\nThe `visit_ClassDef` method checks that each class definition in the program meets certain requirements. Specifically, it checks that the class has no decorators except for `@dataclass`, inherits only from `PlutusData`, and that `PlutusData` is imported in order to use datum classes. If any of these requirements are not met, an assertion error is raised. \n\nOverall, this code ensures that the necessary imports and class definitions are present in a Python program in order to use datum classes. It is likely used as part of a larger project that involves working with PlutusData and Datum objects. \n\nExample usage:\n\n```python\nfrom opshin import RewriteImportPlutusData\n\n# create an instance of the class\ntransformer = RewriteImportPlutusData()\n\n# apply the transformation to the AST of a Python program\nnew_ast = transformer.visit(old_ast)\n```",
      "questions": "1. What is the purpose of the `RewriteImportPlutusData` class?\n    \n    The `RewriteImportPlutusData` class checks that there was an import of dataclass if there are any class definitions.\n\n2. What does the `visit_ImportFrom` method do?\n    \n    The `visit_ImportFrom` method checks that the program contains one 'from pycardano import Datum as Anything, PlutusData' and sets the `imports_plutus_data` attribute to True.\n\n3. What does the `visit_ClassDef` method do?\n    \n    The `visit_ClassDef` method checks that class definitions have no decorators but @dataclass, inherit only from PlutusData, and PlutusData must be imported in order to use datum classes."
    },
    {
      "fileName": "rewrite_import_typing.py",
      "filePath": "opshin/rewrite/rewrite_import_typing.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_import_typing.py",
      "summary": "The code is a Python module that checks whether the `typing` module has been imported and used correctly in a program that defines classes. The module is called `RewriteImportTyping` and is a subclass of `CompilingNodeTransformer`, which is a utility class that traverses and modifies the abstract syntax tree (AST) of a Python program. The `RewriteImportTyping` class has two methods that override methods in the `CompilingNodeTransformer` class: `visit_ImportFrom` and `visit_ClassDef`.\n\nThe `visit_ImportFrom` method checks whether an `ImportFrom` node in the AST corresponds to an import statement of the `typing` module with the correct names and no aliases. If the import statement is correct, the method sets a flag `imports_typing` to `True`. If the import statement is incorrect, the method raises an assertion error. If the node does not correspond to an import statement of the `typing` module, the method returns the node unchanged.\n\nThe `visit_ClassDef` method checks whether the `imports_typing` flag is `True`. If it is not, the method raises an assertion error, because the `typing` module is required to define data classes. If the flag is `True`, the method returns the node unchanged.\n\nThe purpose of this code is to enforce a coding standard that requires the `typing` module to be imported and used correctly in programs that define data classes. Data classes are a feature introduced in Python 3.7 that provide a concise way to define classes that are primarily used to store data. The `typing` module provides type hints that can be used to specify the types of the attributes of a data class. By enforcing the correct usage of the `typing` module, the code ensures that data classes are defined consistently and can be used effectively in the larger project.\n\nHere is an example of how the `RewriteImportTyping` class can be used in a Python program:\n\n```\nfrom opshin import RewriteImportTyping\nfrom ast import parse\n\nprogram = \"\"\"\nfrom typing import Dict, List, Union\n\nclass Person:\n    name: str\n    age: int\n\"\"\"\n\ntree = parse(program)\ntransformer = RewriteImportTyping()\nnew_tree = transformer.visit(tree)\n\n# The new_tree is the same as the original tree, because the import statement is correct\n```",
      "questions": "1. What is the purpose of this code?\n- This code checks if there was an import of dataclass if there are any class definitions.\n\n2. What is the `CompilingNodeTransformer` class used for?\n- The `CompilingNodeTransformer` class is used as a base class for AST transformers that operate on the Python source code.\n\n3. What is the significance of the `imports_typing` attribute?\n- The `imports_typing` attribute is used to keep track of whether the `typing` module has been imported or not, which is necessary for using data classes."
    },
    {
      "fileName": "rewrite_inject_builtin_constr.py",
      "filePath": "opshin/rewrite/rewrite_inject_builtin_constr.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_inject_builtin_constr.py",
      "summary": "The code in this file is responsible for injecting constructors for the built-in types that double function as type annotations. This is achieved through the use of the `CompilingNodeTransformer` class from the `util` module, which is inherited by the `RewriteInjectBuiltinsConstr` class defined in this file. \n\nThe `RewriteInjectBuiltinsConstr` class defines a `visit_Module` method that takes a `TypedModule` node as input and returns a modified `TypedModule` node. The method first creates a list of additional assignments that will be added to the module body. For each of the built-in types `bytes`, `int`, `str`, and `bool`, the method creates a new type object by calling the `constr_type` method on the type object and then creates a new `TypedAssign` node that assigns a lambda function to the type name. The lambda function takes a single argument `_` and returns the result of calling the `constr` method on the type object. \n\nThe `constr` method is defined on each of the built-in type objects and returns a new instance of the type. The lambda function assigned to each type name effectively creates a constructor function for the type that can be used as a type annotation. \n\nFinally, the `visit_Module` method creates a copy of the input node, prepends the list of additional assignments to the module body, and returns the modified node. \n\nOverall, this code is used to add constructor functions for the built-in types that can be used as type annotations in the larger project. For example, the following code snippet demonstrates how the `int` constructor can be used as a type annotation:\n\n```\ndef add_numbers(a: int, b: int) -> int:\n    return a + b\n```",
      "questions": "1. What is the purpose of this code?\n    \n    This code injects constructors for the built-in types that double function as type annotations.\n\n2. What is the `CompilingNodeTransformer` class and how is it used in this code?\n    \n    `CompilingNodeTransformer` is a class that is used to transform AST nodes during the compilation process. In this code, it is subclassed to create a custom transformer that injects constructors for built-in types.\n\n3. What types are being injected and how are they being constructed?\n    \n    The types being injected are `ByteStringType`, `IntegerType`, `StringType`, and `BoolType`. They are being constructed using the `constr_type()` method and a lambda function that takes a single argument and returns the type."
    },
    {
      "fileName": "rewrite_inject_builtins.py",
      "filePath": "opshin/rewrite/rewrite_inject_builtins.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_inject_builtins.py",
      "summary": "The code is a Python module that injects initialization of built-in functions into an abstract syntax tree (AST) of a Python program. The purpose of this code is to provide a way to add additional built-in functions to a Python program at runtime. \n\nThe module imports the `copy` function from the `copy` module, as well as the `TypedModule` class and other classes from the `typed_ast` and `util` modules, respectively. It defines a class called `RewriteInjectBuiltins` that inherits from `CompilingNodeTransformer`, which is a class that can be used to modify an AST. \n\nThe `RewriteInjectBuiltins` class has a `visit_Module` method that takes an AST node of type `TypedModule` as input and returns a modified version of the same node. The method first creates an empty list called `additional_assigns`. It then iterates over the `PythonBuiltIn` enum, which contains the names and values of all built-in functions in Python. For each built-in function, the method creates a new `TypedAssign` node that assigns a lambda function to a new variable with the same name as the built-in function. The lambda function takes a single argument and returns the value of the built-in function. The `additional_assigns` list is then populated with these new `TypedAssign` nodes. \n\nThe method then creates a copy of the input AST node using the `copy` function and assigns it to the variable `md`. The `body` attribute of `md` is then modified by prepending the `additional_assigns` list to the original `body` attribute of the input node. Finally, the modified `md` node is returned. \n\nThis code can be used in the larger project to dynamically add new built-in functions to a Python program at runtime. For example, if the project needs to support a custom data type that is not natively supported by Python, this code can be used to add new built-in functions that operate on that data type. \n\nExample usage:\n\n```\nfrom opshin import RewriteInjectBuiltins\nfrom typed_ast import ast3\n\n# create an AST node\nnode = ast3.parse(\"x = len([1, 2, 3])\")\n\n# create an instance of RewriteInjectBuiltins\ninjector = RewriteInjectBuiltins()\n\n# modify the AST node\nnew_node = injector.visit(node)\n\n# print the modified AST node\nprint(ast3.dump(new_node))\n```",
      "questions": "1. What is the purpose of the `RewriteInjectBuiltins` class?\n- The `RewriteInjectBuiltins` class is a node transformer that injects initialization of the builtin functions.\n\n2. What is the significance of the `PythonBuiltIn` and `PythonBuiltInTypes` variables?\n- `PythonBuiltIn` is a list of built-in functions in Python, while `PythonBuiltInTypes` is a dictionary that maps each built-in function to its corresponding type.\n- These variables are used to initialize the built-in functions in the `visit_Module` method.\n\n3. What is the purpose of the `RawPlutoExpr` and `plt.Lambda` objects?\n- The `RawPlutoExpr` object represents a raw Pluto expression, while `plt.Lambda` is a function that creates a lambda expression.\n- These objects are used to create a lambda expression for each built-in function, which is then assigned to a `TypedAssign` object and added to the `additional_assigns` list."
    },
    {
      "fileName": "rewrite_remove_type_stuff.py",
      "filePath": "opshin/rewrite/rewrite_remove_type_stuff.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_remove_type_stuff.py",
      "summary": "The code in this file is a part of a larger project called opshin and is responsible for removing class reassignments without constructors. The purpose of this code is to ensure that classes are not reassigned without a constructor, which can lead to errors and inconsistencies in the code. \n\nThe code imports the `TypedAssign` and `ClassType` classes from the `typed_ast` module and the `CompilingNodeTransformer` class from the `util` module. It then defines a new class called `RewriteRemoveTypeStuff` that inherits from `CompilingNodeTransformer`. \n\nThe `RewriteRemoveTypeStuff` class has a single method called `visit_Assign` that takes a `TypedAssign` node as input and returns a `TypedAssign` node or `None`. The method first checks that the assignment is only to one variable and not multiple variables. It then checks if the value being assigned is an instance of the `ClassType` class. If it is, the method tries to call the constructor of the class using `node.value.typ.constr()`. If the constructor cannot be called due to a `NotImplementedError`, the method returns `None`. If the attribute is untyped, the method simply passes. Finally, the method returns the original `TypedAssign` node.\n\nThis code can be used in the larger project to ensure that classes are not reassigned without a constructor, which can lead to errors and inconsistencies in the code. For example, if a class is reassigned without a constructor, it may not be properly initialized, leading to unexpected behavior or errors later in the code. By removing these reassignments, the code becomes more reliable and easier to maintain. \n\nAn example of how this code can be used is shown below:\n\n```\nfrom opshin.rewrite import RewriteRemoveTypeStuff\nfrom typed_ast import ast3\n\n# create an AST node for a class reassignment without a constructor\nnode = ast3.parse(\"MyClass = MyClass()\").body[0]\n\n# create an instance of the RewriteRemoveTypeStuff class\ntransformer = RewriteRemoveTypeStuff()\n\n# apply the transformer to the AST node\nnew_node = transformer.visit(node)\n\n# the new_node will be None since the class reassignment does not have a constructor\n```",
      "questions": "1. What is the purpose of this code?\n    \n    This code is a part of the opshin project and its purpose is to remove class reassignments without constructors.\n\n2. What is the `RewriteRemoveTypeStuff` class doing?\n    \n    The `RewriteRemoveTypeStuff` class is a subclass of `CompilingNodeTransformer` and it overrides the `visit_Assign` method to remove class reassignments without constructors.\n\n3. What is the `try` block in the `visit_Assign` method doing?\n    \n    The `try` block in the `visit_Assign` method is trying to instantiate the constructor of the class type of the node's value. If the constructor cannot be instantiated, the node is returned as None."
    },
    {
      "fileName": "rewrite_subscript38.py",
      "filePath": "opshin/rewrite/rewrite_subscript38.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_subscript38.py",
      "summary": "The code in this file is a part of the opshin project and it aims to rewrite all Index/Slice occurrences to look like they do in Python 3.9 onwards, rather than Python 3.8. This is achieved through the use of the `RewriteSubscript38` class, which inherits from the `CompilingNodeTransformer` class. \n\nThe `RewriteSubscript38` class has a single method called `visit_Index`, which takes an `Index` node as input and returns an `AST` node. This method is responsible for visiting all `Index` nodes in the code and rewriting them to match the syntax used in Python 3.9 onwards. \n\nThe `visit_Index` method achieves this by calling the `visit` method on the `value` attribute of the `Index` node. This ensures that any nested `Index` nodes are also rewritten to match the new syntax. \n\nOverall, this code is an important part of the opshin project as it ensures that all Index/Slice occurrences in the codebase are consistent with the latest version of Python. This can help to improve the readability and maintainability of the code, as well as ensuring that it is compatible with the latest version of the language. \n\nExample usage of this code might look like:\n\n```\nfrom opshin.rewrite_subscript38 import RewriteSubscript38\nfrom ast import parse\n\ncode = \"my_list[0:5]\"\ntree = parse(code)\nrewriter = RewriteSubscript38()\nnew_tree = rewriter.visit(tree)\n```\n\nIn this example, the `RewriteSubscript38` class is used to rewrite the `Index` node in the `tree` object to match the syntax used in Python 3.9 onwards. The resulting `new_tree` object can then be used in further processing or compilation steps.",
      "questions": "1. What is the purpose of this code?\n    \n    This code is intended to rewrite all Index/Slice occurrences to look like they do in Python 3.9 onwards, rather than Python 3.8.\n\n2. What is the `CompilingNodeTransformer` class used for?\n    \n    The `CompilingNodeTransformer` class is being inherited by the `RewriteSubscript38` class, and is likely used to transform nodes in the AST during compilation.\n\n3. What is the `visit_Index` method doing?\n    \n    The `visit_Index` method is overriding the `visit_Index` method of the `CompilingNodeTransformer` class, and is returning the result of calling `self.visit(node.value)`. This is likely used to transform Index nodes in the AST."
    },
    {
      "fileName": "rewrite_tuple_assign.py",
      "filePath": "opshin/rewrite/rewrite_tuple_assign.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_tuple_assign.py",
      "summary": "The `RewriteTupleAssign` class is a node transformer that rewrites all occurrences of assignments to tuples to assignments to single values. This is done by recursively resolving multiple layers of tuples and assigning the deconstructed parts to the original variable names. \n\nThe `visit_Assign` method is responsible for rewriting assignments to tuples. It checks if the target of the assignment is a tuple and if so, it generates a unique ID and creates a new assignment for each element in the tuple. The new assignments assign the deconstructed parts of the tuple to the original variable names. The method then recursively resolves multiple layers of tuples and returns the transformed code.\n\nThe `visit_For` method is responsible for rewriting deconstruction in for loops. It checks if the target of the for loop is a tuple and if so, it creates a new variable to hold the tuple and assigns the deconstructed parts of the tuple to the original variable names. The method then recursively resolves multiple layers of tuples and returns the transformed code.\n\nThis code can be used in the larger project to simplify code that uses tuple assignments. It can be particularly useful when dealing with complex data structures that are represented as tuples. For example, consider the following code:\n\n```\na, (b, c), d = some_tuple\n```\n\nThis code can be rewritten using the `RewriteTupleAssign` class as follows:\n\n```\ntemp = some_tuple\na = temp[0]\nb = temp[1][0]\nc = temp[1][1]\nd = temp[2]\n```\n\nThis makes the code easier to read and understand, especially for developers who are not familiar with tuple assignments. Overall, the `RewriteTupleAssign` class is a useful tool for simplifying code and improving readability.",
      "questions": "1. What is the purpose of this code?\n    \n    This code is a module that rewrites all occurrences of assignments to tuples to assignments to single values.\n\n2. What external dependencies does this code have?\n    \n    This code imports `copy` and `typing` modules from Python's standard library, as well as the `ast` module. It also imports a `CompilingNodeTransformer` class from a `util` module located in a parent directory.\n\n3. How does this code handle nested tuples?\n    \n    This code recursively resolves multiple layers of tuples in both assignments and for loops. However, further layers of nested tuples should be handled by the normal tuple assignment."
    },
    {
      "fileName": "rewrite_zero_ary.py",
      "filePath": "opshin/rewrite/rewrite_zero_ary.py",
      "url": "https://github.com/opshin/opshin/opshin/rewrite/rewrite_zero_ary.py",
      "summary": "The code in this file is responsible for rewriting functions that do not take any arguments to take a single argument of None. It also rewrites function calls without arguments to pass in a Unit instance. This is done through the use of the `RewriteZeroAry` class, which inherits from `CompilingNodeTransformer`.\n\nThe `visit_FunctionDef` method of `RewriteZeroAry` is responsible for rewriting the function definitions. It checks if the function takes zero arguments by checking the length of the `args` attribute of the `node` parameter. If the function takes zero arguments, it appends a new argument to the `args` attribute that is a `Constant` instance with a value of `None`. It also appends a `NoneInstanceType` to the `argtyps` attribute of the `FunctionType` instance in the `typ` attribute of the `node` parameter. This ensures that the function signature is updated to take a single argument of `None`.\n\nThe `visit_Call` method of `RewriteZeroAry` is responsible for rewriting the function calls. It first checks if the function being called is the `dataclass` function, which should not be rewritten. If it is not the `dataclass` function, it checks if the function signature expects a single argument of `UnitInstanceType` and if the function call has no arguments. If both of these conditions are true, it appends a new argument to the `args` attribute of the `node` parameter that is a `TypedConstant` instance with a value of `None` and a type of `UnitInstanceType`. This ensures that the function call is updated to pass in a `Unit` instance.\n\nOverall, this code is useful for ensuring that all functions in the project have a consistent signature and that function calls are made with the correct arguments. It can be used as a part of a larger project to ensure that all functions are standardized and that function calls are made correctly. \n\nExample usage:\n\n```\nfrom opshin import RewriteZeroAry\n\n# create an instance of the RewriteZeroAry class\nrewriter = RewriteZeroAry()\n\n# apply the rewriter to a function definition\ndef my_function():\n    print(\"Hello, world!\")\nrewriter.visit_FunctionDef(my_function)\n\n# apply the rewriter to a function call\nmy_function()\nrewriter.visit_Call(my_function)\n```",
      "questions": "1. What is the purpose of this code?\n- This code rewrites functions that don't take arguments into functions that take a singleton None argument and rewrites function calls without arguments to calls that pass Unit into the function, except for the dataclass call.\n\n2. What is the `RewriteZeroAry` class doing?\n- The `RewriteZeroAry` class is a subclass of `CompilingNodeTransformer` that visits `FunctionDef` and `Call` nodes and rewrites them as described in the code's purpose.\n\n3. What is the significance of the `NoneInstanceType` and `UnitInstanceType` classes?\n- `NoneInstanceType` is used to represent the type of `None`, while `UnitInstanceType` is used to represent the type of the `Unit` object, which is used as a placeholder for function calls that don't take any arguments."
    }
  ],
  "folders": [],
  "summary": "The code in the `.autodoc/docs/json/opshin/rewrite` folder is responsible for various transformations and checks on Python code, primarily focusing on ensuring proper usage of imports, type annotations, and assignments. These transformations and checks are implemented using classes that inherit from the `CompilingNodeTransformer` class, which provides a framework for modifying and transforming Python abstract syntax trees (ASTs).\n\nFor example, the `RewriteAugAssign` class rewrites all occurrences of augmented assignments into normal assignments, simplifying the logic of the code that operates on these assignments. The `RewriteForbiddenOverwrites` class prevents certain variable names from being overwritten, which is useful in projects that make use of type annotations or custom decorators.\n\nThe `RewriteImportDataclasses` and `RewriteImportTyping` classes ensure that the `dataclasses` and `typing` modules are imported and used correctly in a Python program, which is important for maintaining code quality and consistency. The `RewriteInjectBuiltinsConstr` class injects constructors for built-in types that double function as type annotations, ensuring that classes are not reassigned without a constructor.\n\nHere's an example of how the `RewriteAugAssign` class can be used:\n\n```python\nfrom ast import parse\nfrom opshin.rewrite_aug_assign import RewriteAugAssign\n\ncode = \"x += 1\"\ntree = parse(code)\nrewriter = RewriteAugAssign()\nnew_tree = rewriter.visit(tree)\nprint(new_tree)\n```\n\nOutput:\n```\nModule(body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Constant(value=1)))])\n```\n\nIn summary, the code in the `.autodoc/docs/json/opshin/rewrite` folder provides a set of tools for transforming and checking Python code to ensure proper usage of imports, type annotations, and assignments. These tools can be used as part of a larger code analysis or linting tool to enforce best practices and maintain code quality and consistency.",
  "questions": ""
}