{
  "fileName": "fractions.py",
  "filePath": "opshin/std/fractions.py",
  "url": "https://github.com/opshin/opshin/opshin/std/fractions.py",
  "summary": "# Opshin Fraction Implementation\n\nThis file contains an implementation of fractions in the Opshin project. The `Fraction` class is defined as a dataclass that inherits from `PlutusData`. The purpose of this implementation is to provide basic arithmetic operations for fractions, including addition, subtraction, multiplication, and division. \n\nThe implementation does not maintain the smallest possible notation invariants for the sake of efficiency. Instead, the user has full control over when to normalize the fractions and should do so using the `norm_fraction` function. \n\nThe file also includes several helper functions for normalizing fractions, including `_norm_signs_fraction` and `_norm_gcd_fraction`. The `norm_fraction` function combines these two helper functions to restore the invariant that the numerator and denominator are in the smallest possible denomination and the denominator is greater than 0.\n\nThe file includes the following functions:\n\n- `add_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the sum of two fractions\n- `neg_fraction(a: Fraction) -> Fraction`: returns the negation of a fraction\n- `sub_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the difference between two fractions\n- `mul_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the product of two fractions\n- `div_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the quotient of two fractions\n- `_norm_signs_fraction(a: Fraction) -> Fraction`: restores the invariant that the denominator is greater than 0\n- `_norm_gcd_fraction(a: Fraction) -> Fraction`: restores the invariant that the numerator and denominator are in the smallest possible denomination\n- `norm_fraction(a: Fraction) -> Fraction`: restores both invariants\n- `ge_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is greater than or equal to `b`\n- `le_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is less than or equal to `b`\n- `eq_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is equal to `b`\n- `lt_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is less than `b`\n- `gt_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is greater than `b`\n\nHere is an example of how to use the `Fraction` class and the arithmetic functions:\n\n```python\na = Fraction(1, 2)\nb = Fraction(3, 4)\n\nc = add_fraction(a, b)  # c = Fraction(5, 4)\nd = sub_fraction(a, b)  # d = Fraction(-1, 4)\ne = mul_fraction(a, b)  # e = Fraction(3, 8)\nf = div_fraction(a, b)  # f = Fraction(2, 3)\n\ng = norm_fraction(Fraction(2, -4))  # g = Fraction(-1, 2)\n\nh = ge_fraction(a, b)  # h = False\ni = eq_fraction(a, Fraction(2, 4))  # i = True\nj = lt_fraction(a, b)  # j = True\n```",
  "questions": "1. What is the purpose of the `PlutusData` superclass for the `Fraction` class?\n- The `PlutusData` superclass is used to indicate that the `Fraction` class is intended to be used in the Plutus smart contract platform.\n\n2. Why does the code not maintain the smallest possible notation invariants for fractions?\n- The code sacrifices the smallest possible notation invariants for efficiency reasons, and instead leaves it up to the user to normalize fractions using the `norm_fraction` function.\n\n3. What is the purpose of the `_norm_signs_fraction` function?\n- The `_norm_signs_fraction` function is used to ensure that the denominator of a fraction is always positive, which is necessary for certain operations to work correctly."
}