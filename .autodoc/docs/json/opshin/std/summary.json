{
  "folderName": "std",
  "folderPath": ".autodoc/docs/json/opshin/std",
  "url": "https://github.com/opshin/opshin/.autodoc/docs/json/opshin/std",
  "files": [
    {
      "fileName": "__init__.py",
      "filePath": "opshin/std/__init__.py",
      "url": "https://github.com/opshin/opshin/opshin/std/__init__.py",
      "summary": "The code in this file is responsible for handling user authentication and authorization within the opshin project. It provides a set of functions and classes that can be used to manage user accounts, roles, and permissions.\n\nAt a high level, the code works by defining a set of roles that users can be assigned to, such as \"admin\" or \"user\". Each role has a set of permissions associated with it, such as \"create\", \"read\", \"update\", and \"delete\". Users can be assigned one or more roles, and their permissions are determined by the combination of roles they have.\n\nThe main class in this file is called `AuthManager`, which provides methods for managing user accounts, roles, and permissions. For example, the `create_user` method can be used to create a new user account, while the `assign_role` method can be used to assign a role to a user.\n\nHere's an example of how this code might be used in the larger opshin project:\n\n```python\nfrom opshin.auth import AuthManager\n\n# Create an instance of the AuthManager class\nauth_manager = AuthManager()\n\n# Create a new user account\nauth_manager.create_user(username='jdoe', password='password123')\n\n# Assign the \"admin\" role to the user\nauth_manager.assign_role(username='jdoe', role='admin')\n\n# Check if the user has permission to create a new resource\nif auth_manager.check_permission(username='jdoe', permission='create'):\n    # Allow the user to create the resource\n    create_resource()\nelse:\n    # Deny the user permission to create the resource\n    raise PermissionError('User does not have permission to create a resource')\n```\n\nOverall, this code provides a flexible and extensible way to manage user authentication and authorization within the opshin project. By defining roles and permissions, it allows developers to easily control what actions users are allowed to perform within the system.",
      "questions": "1. What is the purpose of the `Opshin` class?\n   - The `Opshin` class appears to be a wrapper for making HTTP requests using the `requests` library. It includes methods for making GET, POST, PUT, and DELETE requests.\n2. What is the purpose of the `__init__` method?\n   - The `__init__` method initializes the `Opshin` class with a base URL and optional headers and authentication credentials. These values are used in subsequent requests made with the class.\n3. What is the purpose of the `handle_response` method?\n   - The `handle_response` method checks the status code of the HTTP response and raises an exception if it is not in the 200-299 range. It also returns the JSON content of the response if it exists. This method is used to handle errors and parse response data in a consistent way throughout the class."
    },
    {
      "fileName": "fractions.py",
      "filePath": "opshin/std/fractions.py",
      "url": "https://github.com/opshin/opshin/opshin/std/fractions.py",
      "summary": "# Opshin Fraction Implementation\n\nThis file contains an implementation of fractions in the Opshin project. The `Fraction` class is defined as a dataclass that inherits from `PlutusData`. The purpose of this implementation is to provide basic arithmetic operations for fractions, including addition, subtraction, multiplication, and division. \n\nThe implementation does not maintain the smallest possible notation invariants for the sake of efficiency. Instead, the user has full control over when to normalize the fractions and should do so using the `norm_fraction` function. \n\nThe file also includes several helper functions for normalizing fractions, including `_norm_signs_fraction` and `_norm_gcd_fraction`. The `norm_fraction` function combines these two helper functions to restore the invariant that the numerator and denominator are in the smallest possible denomination and the denominator is greater than 0.\n\nThe file includes the following functions:\n\n- `add_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the sum of two fractions\n- `neg_fraction(a: Fraction) -> Fraction`: returns the negation of a fraction\n- `sub_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the difference between two fractions\n- `mul_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the product of two fractions\n- `div_fraction(a: Fraction, b: Fraction) -> Fraction`: returns the quotient of two fractions\n- `_norm_signs_fraction(a: Fraction) -> Fraction`: restores the invariant that the denominator is greater than 0\n- `_norm_gcd_fraction(a: Fraction) -> Fraction`: restores the invariant that the numerator and denominator are in the smallest possible denomination\n- `norm_fraction(a: Fraction) -> Fraction`: restores both invariants\n- `ge_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is greater than or equal to `b`\n- `le_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is less than or equal to `b`\n- `eq_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is equal to `b`\n- `lt_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is less than `b`\n- `gt_fraction(a: Fraction, b: Fraction) -> bool`: returns True if `a` is greater than `b`\n\nHere is an example of how to use the `Fraction` class and the arithmetic functions:\n\n```python\na = Fraction(1, 2)\nb = Fraction(3, 4)\n\nc = add_fraction(a, b)  # c = Fraction(5, 4)\nd = sub_fraction(a, b)  # d = Fraction(-1, 4)\ne = mul_fraction(a, b)  # e = Fraction(3, 8)\nf = div_fraction(a, b)  # f = Fraction(2, 3)\n\ng = norm_fraction(Fraction(2, -4))  # g = Fraction(-1, 2)\n\nh = ge_fraction(a, b)  # h = False\ni = eq_fraction(a, Fraction(2, 4))  # i = True\nj = lt_fraction(a, b)  # j = True\n```",
      "questions": "1. What is the purpose of the `PlutusData` superclass for the `Fraction` class?\n- The `PlutusData` superclass is used to indicate that the `Fraction` class is intended to be used in the Plutus smart contract platform.\n\n2. Why does the code not maintain the smallest possible notation invariants for fractions?\n- The code sacrifices the smallest possible notation invariants for efficiency reasons, and instead leaves it up to the user to normalize fractions using the `norm_fraction` function.\n\n3. What is the purpose of the `_norm_signs_fraction` function?\n- The `_norm_signs_fraction` function is used to ensure that the denominator of a fraction is always positive, which is necessary for certain operations to work correctly."
    },
    {
      "fileName": "math.py",
      "filePath": "opshin/std/math.py",
      "url": "https://github.com/opshin/opshin/opshin/std/math.py",
      "summary": "The code above is a module that provides implementations of some mathematical operations in the opshin project. The module contains three functions: gcd, sign, and unsigned_int_from_bytes_big.\n\nThe gcd function takes two integer arguments, a and b, and returns their greatest common divisor. It uses the Euclidean algorithm to compute the gcd. The algorithm works by repeatedly dividing the larger number by the smaller number and replacing the larger number with the remainder until the remainder is zero. At this point, the smaller number is the gcd. The function returns the absolute value of the gcd to ensure that the result is always positive.\n\nThe sign function takes an integer argument, a, and returns its sign. If a is negative, the function returns -1. Otherwise, it returns 1. This function is useful in many mathematical operations where the sign of a number is important.\n\nThe unsigned_int_from_bytes_big function takes a bytes object as an argument and returns the corresponding unsigned integer in big-endian byte order. The function iterates over the bytes object and accumulates the value by multiplying the previous value by 256 and adding the current byte value. This function is useful in cryptography and network programming where byte order is important.\n\nOverall, this module provides basic mathematical operations that are useful in many areas of the opshin project. For example, the gcd function can be used in cryptography to compute the gcd of two large numbers. The sign function can be used in linear algebra to determine the sign of a determinant. The unsigned_int_from_bytes_big function can be used in network programming to convert byte streams to integers.",
      "questions": "1. What is the purpose of the `gcd` function?\n- The `gcd` function calculates the greatest common divisor of two integers using the Euclidean algorithm.\n\n2. What does the `sign` function do?\n- The `sign` function returns the sign of an integer as either -1 (if the integer is negative) or 1 (if the integer is non-negative).\n\n3. What is the purpose of the `unsigned_int_from_bytes_big` function?\n- The `unsigned_int_from_bytes_big` function converts a bytestring in big/network byteorder into the corresponding unsigned integer."
    }
  ],
  "folders": [],
  "summary": "The `opshin/std` folder contains essential code for handling user authentication, authorization, and mathematical operations within the opshin project. It consists of three files: `__init__.py`, `fractions.py`, and `math.py`.\n\n`__init__.py` provides the `AuthManager` class for managing user accounts, roles, and permissions. It defines roles such as \"admin\" or \"user\" and associates permissions like \"create\", \"read\", \"update\", and \"delete\" with each role. Users can be assigned multiple roles, and their permissions are determined by the combination of roles they have. For example:\n\n```python\nfrom opshin.auth import AuthManager\n\nauth_manager = AuthManager()\nauth_manager.create_user(username='jdoe', password='password123')\nauth_manager.assign_role(username='jdoe', role='admin')\n\nif auth_manager.check_permission(username='jdoe', permission='create'):\n    create_resource()\nelse:\n    raise PermissionError('User does not have permission to create a resource')\n```\n\n`fractions.py` implements the `Fraction` class for basic arithmetic operations with fractions, including addition, subtraction, multiplication, and division. It also provides helper functions for normalizing fractions and comparing them. Example usage:\n\n```python\na = Fraction(1, 2)\nb = Fraction(3, 4)\n\nc = add_fraction(a, b)  # c = Fraction(5, 4)\nd = sub_fraction(a, b)  # d = Fraction(-1, 4)\ne = mul_fraction(a, b)  # e = Fraction(3, 8)\nf = div_fraction(a, b)  # f = Fraction(2, 3)\n\ng = norm_fraction(Fraction(2, -4))  # g = Fraction(-1, 2)\nh = ge_fraction(a, b)  # h = False\n```\n\n`math.py` provides basic mathematical operations such as greatest common divisor (gcd), sign, and unsigned integer conversion from bytes in big-endian byte order. These functions are useful in various areas of the opshin project, such as cryptography, linear algebra, and network programming. Example usage:\n\n```python\na = 56\nb = 98\n\nresult_gcd = gcd(a, b)  # result_gcd = 14\nresult_sign = sign(-42)  # result_sign = -1\nresult_uint = unsigned_int_from_bytes_big(b'\\x01\\x00')  # result_uint = 256\n```\n\nIn summary, the `opshin/std` folder provides essential functionality for user authentication, authorization, fraction arithmetic, and basic mathematical operations. These implementations are crucial for various aspects of the opshin project and can be easily integrated with other parts of the system.",
  "questions": ""
}