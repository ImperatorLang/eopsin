<!doctype html>
<html lang="en">
<head>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<link rel="icon" href="https://raw.githubusercontent.com/OpShin/opshin/dev/docs/opshin_32.png" sizes="32x32" type="image/png">
<title>opshin.tests.test_ops API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<style>
.github-corner:hover .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
0%,
100% {
transform: rotate(0)
}
20%,
60% {
transform: rotate(-25deg)
}
40%,
80% {
transform: rotate(10deg)
}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm {
animation: none
}
.github-corner .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
}
</style>
<a href="https://github.com/opshin/opshin" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250"
style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
</path>
<path
d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path
d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
fill="currentColor" class="octo-body"></path>
</svg>
</a>
<article id="content">
<header>
<h1 class="title">Module <code>opshin.tests.test_ops</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import unittest

import cbor2
import hypothesis
import pycardano
from frozendict import frozendict
import frozenlist as fl
from hypothesis import example, given
from hypothesis import strategies as st

from uplc import ast as uplc, eval as uplc_eval
from uplc.ast import (
    PlutusMap,
    PlutusConstr,
    PlutusList,
    PlutusInteger,
    PlutusByteString,
)

from . import PLUTUS_VM_PROFILE
from .utils import eval_uplc, eval_uplc_value, Unit
from .. import compiler

hypothesis.settings.load_profile(PLUTUS_VM_PROFILE)

from opshin.ledger.api_v2 import (
    FinitePOSIXTime,
    PosInfPOSIXTime,
    UpperBoundPOSIXTime,
    FalseData,
    TrueData,
)


def frozenlist(l):
    l = fl.FrozenList(l)
    l.freeze()
    return l


pos_int = st.integers(min_value=0, max_value=2**64 - 1)


uplc_data_integer = st.builds(PlutusInteger, st.integers())
uplc_data_bytestring = st.builds(PlutusByteString, st.binary())


def rec_data_strategies(uplc_data):
    uplc_data_list = st.builds(lambda x: PlutusList(frozenlist(x)), st.lists(uplc_data))
    uplc_data_constr = st.builds(
        lambda x, y: PlutusConstr(x, frozenlist(y)),
        pos_int,
        st.lists(uplc_data),
    )
    uplc_data_map = st.builds(
        PlutusMap,
        st.dictionaries(
            st.one_of(
                uplc_data_integer, uplc_data_bytestring
            ),  # TODO technically constr is legal too, but causes hashing error
            uplc_data,
            dict_class=frozendict,
        ),
    )
    return st.one_of(uplc_data_map, uplc_data_list, uplc_data_constr)


uplc_data = st.recursive(
    st.one_of(uplc_data_bytestring, uplc_data_integer),
    rec_data_strategies,
    max_leaves=4,
)
uplc_data_list = st.builds(lambda x: PlutusList(frozenlist(x)), st.lists(uplc_data))

# TODO fix handling of these strings
formattable_text = st.from_regex(r&#34;\A((?![&#39;\\])[ -~])*\Z&#34;)


class OpTest(unittest.TestCase):
    @given(x=st.booleans(), y=st.booleans())
    def test_and_bool(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x and y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(bool(ret), x and y, &#34;and returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_or_bool(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x or y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(bool(ret), x or y, &#34;or returned wrong value&#34;)

    @given(x=st.booleans())
    def test_not_bool(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(x=st.integers())
    def test_usub_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; int:
    return -x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(ret, -x, &#34;not returned wrong value&#34;)

    @given(x=st.integers())
    def test_uadd_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; int:
    return +x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(ret, +x, &#34;not returned wrong value&#34;)

    @given(x=st.integers())
    def test_not_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_add_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x + y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_sub_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x - y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x - y, &#34;- returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_mul_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x * y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_div_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x // y
            &#34;&#34;&#34;
        try:
            exp = x // y
        except ZeroDivisionError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;// returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_mod_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x % y
            &#34;&#34;&#34;
        try:
            exp = x % y
        except ZeroDivisionError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;% returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers(min_value=0, max_value=20))
    def test_pow_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x ** y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x**y, &#34;** returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers(min_value=-20, max_value=-1))
    def test_neg_pow_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x ** y
            &#34;&#34;&#34;
        try:
            eval_uplc_value(source_code, x, y)
            fail = True
        except Exception:
            fail = False
        self.assertFalse(fail, &#34;** worked with negative exponent&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_add_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bytes:
    return x + y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_add_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    return x + y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y.encode(&#34;utf8&#34;)).decode(
            &#34;utf8&#34;
        )
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers(), z=st.integers())
    @example(b&#34;\x00&#34;, -2, 0)
    @example(b&#34;1234&#34;, 1, 2)
    @example(b&#34;1234&#34;, 2, 4)
    @example(b&#34;1234&#34;, 2, 2)
    @example(b&#34;1234&#34;, 3, 3)
    @example(b&#34;1234&#34;, 3, 1)
    def test_slice_bytes(self, x, y, z):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int, z: int) -&gt; bytes:
    return x[y:z]
            &#34;&#34;&#34;
        try:
            exp = x[y:z]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y, z)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers())
    @example(b&#34;\x00&#34;, -2)
    @example(b&#34;1234&#34;, 1)
    @example(b&#34;1234&#34;, 2)
    @example(b&#34;1234&#34;, 2)
    @example(b&#34;1234&#34;, 3)
    @example(b&#34;1234&#34;, 3)
    def test_slice_bytes_lower(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x[y:]
            &#34;&#34;&#34;
        try:
            exp = x[y:]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers())
    @example(b&#34;\x00&#34;, 0)
    @example(b&#34;1234&#34;, 2)
    @example(b&#34;1234&#34;, 4)
    @example(b&#34;1234&#34;, 2)
    @example(b&#34;1234&#34;, 3)
    @example(b&#34;1234&#34;, 1)
    def test_slice_bytes_upper(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x[:y]
            &#34;&#34;&#34;
        try:
            exp = x[:y]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary())
    @example(b&#34;\x00&#34;)
    @example(b&#34;1234&#34;)
    @example(b&#34;1234&#34;)
    @example(b&#34;1234&#34;)
    @example(b&#34;1234&#34;)
    @example(b&#34;1234&#34;)
    def test_slice_bytes_full(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; bytes:
    return x[:]
            &#34;&#34;&#34;
        try:
            exp = x[:]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers())
    @example(b&#34;1234&#34;, 0)
    @example(b&#34;1234&#34;, 1)
    @example(b&#34;1234&#34;, -1)
    def test_index_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        try:
            exp = x[y]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte index returned wrong value&#34;)

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0], y=-1)
    @example(xs=[0], y=0)
    def test_index_list(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        try:
            exp = xs[y]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, xs, y)
        except Exception as e:
            ret = None
        self.assertEqual(ret, exp, &#34;list index returned wrong value&#34;)

    @given(x=st.lists(st.integers(), max_size=20), y=st.integers(), z=st.integers())
    @example([0], -2, 0)
    @example([1, 2, 3, 4], 1, 2)
    @example([1, 2, 3, 4], 2, 4)
    @example([1, 2, 3, 4], 2, 2)
    @example([1, 2, 3, 4], 3, 3)
    @example([1, 2, 3, 4], 3, 1)
    def test_slice_list(self, x, y, z):
        source_code = &#34;&#34;&#34;
def validator(x: List[int], y: int, z: int) -&gt; List[int]:
    return x[y:z]
            &#34;&#34;&#34;
        try:
            exp = x[y:z]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y, z)
        except:
            ret = None
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in exp] if exp is not None else exp,
            &#34;list slice returned wrong value&#34;,
        )

    @given(x=st.lists(st.integers(), max_size=20), y=st.integers())
    @example([0], -2)
    @example([1, 2, 3, 4], 1)
    @example([1, 2, 3, 4], 2)
    @example([1, 2, 3, 4], 2)
    @example([1, 2, 3, 4], 3)
    @example([1, 2, 3, 4], 3)
    def test_slice_list_lower(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: List[int], y: int) -&gt; List[int]:
    return x[y:]
            &#34;&#34;&#34;
        try:
            exp = x[y:]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in exp] if exp is not None else exp,
            &#34;list slice returned wrong value&#34;,
        )

    @given(x=st.lists(st.integers(), max_size=20), y=st.integers())
    @example([0], 0)
    @example([1, 2, 3, 4], 2)
    @example([1, 2, 3, 4], 4)
    @example([1, 2, 3, 4], 2)
    @example([1, 2, 3, 4], 3)
    @example([1, 2, 3, 4], 1)
    def test_slice_list_upper(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: List[int], y: int) -&gt; List[int]:
    return x[:y]
            &#34;&#34;&#34;
        try:
            exp = x[:y]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in exp] if exp is not None else exp,
            &#34;list slice returned wrong value&#34;,
        )

    @given(x=st.lists(st.integers(), max_size=20))
    @example([0])
    @example([1, 2, 3, 4])
    @example([1, 2, 3, 4])
    @example([1, 2, 3, 4])
    @example([1, 2, 3, 4])
    @example([1, 2, 3, 4])
    def test_slice_list_full(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: List[int]) -&gt; List[int]:
    return x[:]
            &#34;&#34;&#34;
        try:
            exp = x[:]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x)
        except:
            ret = None
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in exp] if exp is not None else exp,
            &#34;list slice returned wrong value&#34;,
        )

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0, 1], y=-1)
    @example(xs=[0, 1], y=0)
    def test_in_list_int(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y in xs, &#34;list in returned wrong value&#34;)

    @given(xs=st.lists(st.binary()), y=st.binary())
    def test_in_list_bytes(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[bytes], y: bytes) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y in xs, &#34;list in returned wrong value&#34;)

    @given(xs=uplc_data_list, y=uplc_data)
    def test_in_list_data(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
from pycardano import Datum as Anything, PlutusData
def validator(x: List[Anything], y: Anything) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y in xs.value, &#34;list in returned wrong value&#34;)

    @given(xs=uplc_data_list, y=uplc_data)
    def test_not_in_list_data(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
from pycardano import Datum as Anything, PlutusData
def validator(x: List[Anything], y: Anything) -&gt; bool:
    return y not in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y not in xs.value, &#34;list not in returned wrong value&#34;)

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0, 1], y=-1)
    @example(xs=[0, 1], y=0)
    def test_not_in_list_int(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; bool:
    return y not in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y not in xs, &#34;list not in returned wrong value&#34;)

    @given(xs=st.lists(st.binary()), y=st.binary())
    def test_not_in_list_bytes(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[bytes], y: bytes) -&gt; bool:
    return y not in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y not in xs, &#34;list not in returned wrong value&#34;)

    @given(x=st.lists(st.integers()))
    def test_not_list(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: List[int]) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_eq_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;bytes eq returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_eq_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;int eq returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_eq_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y.encode(&#34;utf8&#34;))
        self.assertEqual(ret, x == y, &#34;str eq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_eq_bool(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;bool eq returned wrong value&#34;)

    @given(x=uplc_data, y=uplc_data)
    def test_eq_data(self, x, y):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Anything, y: Anything) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;any eq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.integers())
    def test_eq_bool_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: int) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;bool eq int returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_neq_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y.encode(&#34;utf8&#34;))
        self.assertEqual(ret, x != y, &#34;str neq returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_neq_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;int neq returned wrong value&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_neq_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;bytes neq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_neq_bool(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;bool neq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.integers())
    def test_neq_bool_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: int) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;bool neq int returned wrong value&#34;)

    @given(x=uplc_data, y=uplc_data)
    def test_neq_data(self, x, y):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Anything, y: Anything) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;any neq returned wrong value&#34;)

    @given(x=st.integers(min_value=0, max_value=150), y=st.text())
    def test_mul_int_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: str) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y.encode(&#34;utf8&#34;))
        self.assertEqual(ret.decode(&#34;utf8&#34;), x * y, &#34;* returned wrong value&#34;)

    @given(x=st.text(), y=st.integers(min_value=0, max_value=150))
    def test_mul_str_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: int) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y)
        self.assertEqual(ret.decode(&#34;utf8&#34;), x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers(min_value=0, max_value=150), y=st.binary())
    def test_mul_int_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: bytes) -&gt; bytes:
    return x * y
        &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x * y, &#34;bytes int multiplication returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers(min_value=0, max_value=150))
    def test_mul_bytes_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x * y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(
        xs=st.lists(st.integers(), max_size=20), ys=st.lists(st.integers(), max_size=20)
    )
    def test_add_list(self, xs, ys):
        source_code = &#34;&#34;&#34;
def validator(x: List[int], y: List[int]) -&gt; List[int]:
    return x + y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, ys)
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in xs] + [PlutusInteger(y) for y in ys],
            &#34;+ returned wrong value&#34;,
        )

    @given(x=st.integers())
    def test_fmt_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(
            ret.decode(&#34;utf8&#34;), f&#34;{x}&#34;, &#34;int string formatting returned wrong value&#34;
        )

    @given(x=st.booleans())
    def test_fmt_bool(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(
            ret.decode(&#34;utf8&#34;), f&#34;{x}&#34;, &#34;bool string formatting returned wrong value&#34;
        )

    @given(x=st.text())
    def test_fmt_str(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: str) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;))
        self.assertEqual(
            ret.decode(&#34;utf8&#34;), f&#34;{x}&#34;, &#34;string string formatting returned wrong value&#34;
        )

    @given(x=st.binary())
    @example(b&#34;&#39;&#34;)
    @example(b&#39;&#34;&#39;)
    @example(b&#34;\\&#34;)
    @example(b&#34;\r&#34;)
    @example(b&#34;\n&#34;)
    @example(b&#34;\t&#34;)
    @example(b&#34;\x7f&#34;)
    def test_fmt_bytes(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; str:
    return f&#34;{x}&#34;
        &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x).decode(&#34;utf8&#34;)
        if b&#34;&#39;&#34; not in x:
            self.assertEqual(
                ret, f&#34;{x}&#34;, &#34;bytes string formatting returned wrong value&#34;
            )
        else:
            # NOTE: formally this is a bug where we do not have the same semantics as python
            # specifically when &#39; is contained in the string we do not change the quotation marks
            self.assertEqual(
                eval(ret), x, &#34;bytes string formatting returned wrong value&#34;
            )

    @given(x=st.none())
    def test_fmt_none(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: None) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, Unit()).decode(&#34;utf8&#34;)
        self.assertEqual(ret, f&#34;{x}&#34;, &#34;none string formatting returned wrong value&#34;)

    @given(
        x=st.builds(
            UpperBoundPOSIXTime,
            st.one_of(
                st.builds(FinitePOSIXTime, st.integers()), st.builds(PosInfPOSIXTime)
            ),
            st.one_of(st.builds(TrueData), st.builds(FalseData)),
        )
    )
    @example(UpperBoundPOSIXTime(PosInfPOSIXTime(), TrueData()))
    def test_fmt_dataclass(self, x: UpperBoundPOSIXTime):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: UpperBoundPOSIXTime) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;

        ret = eval_uplc_value(source_code, x).decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, f&#34;{x}&#34;, &#34;several element string formatting returned wrong value&#34;
        )

    @given(x=st.integers(), y=st.integers())
    def test_fmt_multiple(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    return f&#34;a{x}b{y}c&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y).decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, f&#34;a{x}b{y}c&#34;, &#34;several element string formatting returned wrong value&#34;
        )

    @given(x=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_tuple_int(self, x):
        params = [f&#34;a{i}&#34; for i in range(len(x))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: int&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, *x if x else [0]).decode(&#34;utf8&#34;)
        exp = f&#34;{tuple(x)}&#34;
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )

    @given(xs=st.lists(formattable_text))
    def test_fmt_tuple_str(self, xs):
        # TODO strings are not properly escaped here
        params = [f&#34;a{i}&#34; for i in range(len(xs))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: str&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(
            source_code, *(x.encode(&#34;utf8&#34;) for x in xs) if xs else [0]
        ).decode(&#34;utf8&#34;)
        exp = f&#34;{tuple(xs)}&#34;
        self.assertEqual(ret, exp, &#34;tuple string formatting returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_fmt_pair_int(self, x, y):
        source_code = f&#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        exp = f&#34;{(x, y)}&#34;
        ret = eval_uplc_value(source_code, x, y).decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )

    @given(x=formattable_text, y=formattable_text)
    def test_fmt_pair_str(self, x, y):
        # TODO strings are not properly escaped here
        source_code = f&#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        exp = f&#34;{(x, y)}&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y.encode(&#34;utf8&#34;)).decode(
            &#34;utf8&#34;
        )
        self.assertEqual(
            ret, exp, &#34;string tuple string formatting returned wrong value&#34;
        )

    @given(xs=st.lists(formattable_text))
    @example([])
    @example([&#34;x&#34;])
    def test_fmt_list_str(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[str]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        exp = f&#34;{list(xs)}&#34;
        ret = eval_uplc_value(source_code, [x.encode(&#34;utf8&#34;) for x in xs]).decode(
            &#34;utf8&#34;
        )
        self.assertEqual(ret, exp, &#34;string list string formatting returned wrong value&#34;)

    @given(xs=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_list_int(self, xs):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        exp = f&#34;{list(xs)}&#34;
        ret = eval_uplc_value(source_code, xs).decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer list string formatting returned wrong value&#34;
        )

    @given(x=st.dictionaries(st.integers(), st.integers()))
    def test_not_dict(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: Dict[int, int]) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(xs=st.dictionaries(st.integers(), st.integers()), y=st.integers())
    def test_index_dict(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: Dict[int, int], y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        try:
            exp = xs[y]
        except KeyError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, xs, y)
        except Exception as e:
            ret = None
        self.assertEqual(ret, exp, &#34;list index returned wrong value&#34;)

    @given(xs=st.dictionaries(formattable_text, st.integers()))
    @example(dict())
    @example({&#34;&#34;: 0})
    def test_fmt_dict_int(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Dict[str, int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        exp = f&#34;{dict(xs)}&#34;
        ret = eval_uplc_value(
            source_code, {k.encode(&#34;utf8&#34;): v for k, v in xs.items()}
        ).decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;dict string formatting returned wrong value&#34;)

    @given(x=uplc_data)
    @example(PlutusByteString(b&#34;&#34;))
    @example(PlutusConstr(0, [PlutusByteString(b&#34;&#39;&#34;)]))
    @example(
        PlutusMap({PlutusInteger(1): PlutusMap({}), PlutusInteger(0): PlutusMap({})})
    )
    def test_fmt_any(self, x):
        x_cbor = uplc.plutus_cbor_dumps(x)
        x_data = pycardano.RawPlutusData(cbor2.loads(x_cbor))
        source_code = &#34;&#34;&#34;
def validator(x: Anything) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        # NOTE: this is technically a deviation from the semantics of pycardano but I expect the pycardano semantics to change soon
        exp = f&#34;RawPlutusData(data={repr(x_data.data)})&#34;
        ret = eval_uplc_value(source_code, pycardano.RawCBOR(x_cbor)).decode(&#34;utf8&#34;)
        if &#34;\\&#39;&#34; in ret:
            RawPlutusData = pycardano.RawPlutusData
            CBORTag = cbor2.CBORTag
            self.assertEqual(
                eval(ret), x_data, &#34;raw cbor string formatting returned wrong value&#34;
            )
        else:
            self.assertEqual(
                ret, exp, &#34;raw cbor string formatting returned wrong value&#34;
            )

    @given(x=st.text())
    def test_not_string(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: str) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;))
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(x=st.binary())
    def test_not_bytes(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    def test_not_unit(self):
        source_code = &#34;&#34;&#34;
def validator(x: None) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, uplc.BuiltinUnit())
        self.assertEqual(bool(ret), not None, &#34;not returned wrong value&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="opshin.tests.test_ops.frozenlist"><code class="name flex">
<span>def <span class="ident">frozenlist</span></span>(<span>l)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.rec_data_strategies"><code class="name flex">
<span>def <span class="ident">rec_data_strategies</span></span>(<span>uplc_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="opshin.tests.test_ops.OpTest"><code class="flex name class">
<span>class <span class="ident">OpTest</span></span>
<span>(</span><span>methodName='runTest')</span>
</code></dt>
<dd>
<div class="desc"><p>A class whose instances are single test cases.</p>
<p>By default, the test code itself should be placed in a method named
'runTest'.</p>
<p>If the fixture may be used for many test cases, create as
many test methods as are needed. When instantiating such a TestCase
subclass, specify in the constructor arguments the name of the test method
that the instance is to execute.</p>
<p>Test authors should subclass TestCase for their own tests. Construction
and deconstruction of the test's environment ('fixture') can be
implemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>
<p>If it is necessary to override the <strong>init</strong> method, the base class
<strong>init</strong> method must always be called. It is important that subclasses
should not change the signature of their <strong>init</strong> method, since instances
of the classes are instantiated automatically by parts of the framework
in order to be run.</p>
<p>When subclassing TestCase, you can set these attributes:
* failureException: determines which exception will be raised when
the instance's assertion methods fail; test methods raising this
exception will be deemed to have 'failed' rather than 'errored'.
* longMessage: determines whether long messages (including repr of
objects used in assert methods) will be printed on failure in <em>addition</em>
to any explicit message passed.
* maxDiff: sets the maximum length of a diff in failure messages
by assert methods using difflib. It is looked up as an instance
attribute so can be configured by individual tests if required.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpTest(unittest.TestCase):
    @given(x=st.booleans(), y=st.booleans())
    def test_and_bool(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x and y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(bool(ret), x and y, &#34;and returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_or_bool(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x or y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(bool(ret), x or y, &#34;or returned wrong value&#34;)

    @given(x=st.booleans())
    def test_not_bool(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(x=st.integers())
    def test_usub_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; int:
    return -x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(ret, -x, &#34;not returned wrong value&#34;)

    @given(x=st.integers())
    def test_uadd_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; int:
    return +x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(ret, +x, &#34;not returned wrong value&#34;)

    @given(x=st.integers())
    def test_not_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_add_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x + y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_sub_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x - y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x - y, &#34;- returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_mul_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x * y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_div_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x // y
            &#34;&#34;&#34;
        try:
            exp = x // y
        except ZeroDivisionError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;// returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_mod_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x % y
            &#34;&#34;&#34;
        try:
            exp = x % y
        except ZeroDivisionError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except Exception:
            ret = None
        self.assertEqual(ret, exp, &#34;% returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers(min_value=0, max_value=20))
    def test_pow_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x ** y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x**y, &#34;** returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers(min_value=-20, max_value=-1))
    def test_neg_pow_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; int:
    return x ** y
            &#34;&#34;&#34;
        try:
            eval_uplc_value(source_code, x, y)
            fail = True
        except Exception:
            fail = False
        self.assertFalse(fail, &#34;** worked with negative exponent&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_add_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bytes:
    return x + y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_add_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    return x + y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y.encode(&#34;utf8&#34;)).decode(
            &#34;utf8&#34;
        )
        self.assertEqual(ret, x + y, &#34;+ returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers(), z=st.integers())
    @example(b&#34;\x00&#34;, -2, 0)
    @example(b&#34;1234&#34;, 1, 2)
    @example(b&#34;1234&#34;, 2, 4)
    @example(b&#34;1234&#34;, 2, 2)
    @example(b&#34;1234&#34;, 3, 3)
    @example(b&#34;1234&#34;, 3, 1)
    def test_slice_bytes(self, x, y, z):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int, z: int) -&gt; bytes:
    return x[y:z]
            &#34;&#34;&#34;
        try:
            exp = x[y:z]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y, z)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers())
    @example(b&#34;\x00&#34;, -2)
    @example(b&#34;1234&#34;, 1)
    @example(b&#34;1234&#34;, 2)
    @example(b&#34;1234&#34;, 2)
    @example(b&#34;1234&#34;, 3)
    @example(b&#34;1234&#34;, 3)
    def test_slice_bytes_lower(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x[y:]
            &#34;&#34;&#34;
        try:
            exp = x[y:]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers())
    @example(b&#34;\x00&#34;, 0)
    @example(b&#34;1234&#34;, 2)
    @example(b&#34;1234&#34;, 4)
    @example(b&#34;1234&#34;, 2)
    @example(b&#34;1234&#34;, 3)
    @example(b&#34;1234&#34;, 1)
    def test_slice_bytes_upper(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x[:y]
            &#34;&#34;&#34;
        try:
            exp = x[:y]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary())
    @example(b&#34;\x00&#34;)
    @example(b&#34;1234&#34;)
    @example(b&#34;1234&#34;)
    @example(b&#34;1234&#34;)
    @example(b&#34;1234&#34;)
    @example(b&#34;1234&#34;)
    def test_slice_bytes_full(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; bytes:
    return x[:]
            &#34;&#34;&#34;
        try:
            exp = x[:]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte slice returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers())
    @example(b&#34;1234&#34;, 0)
    @example(b&#34;1234&#34;, 1)
    @example(b&#34;1234&#34;, -1)
    def test_index_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        try:
            exp = x[y]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(ret, exp, &#34;byte index returned wrong value&#34;)

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0], y=-1)
    @example(xs=[0], y=0)
    def test_index_list(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        try:
            exp = xs[y]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, xs, y)
        except Exception as e:
            ret = None
        self.assertEqual(ret, exp, &#34;list index returned wrong value&#34;)

    @given(x=st.lists(st.integers(), max_size=20), y=st.integers(), z=st.integers())
    @example([0], -2, 0)
    @example([1, 2, 3, 4], 1, 2)
    @example([1, 2, 3, 4], 2, 4)
    @example([1, 2, 3, 4], 2, 2)
    @example([1, 2, 3, 4], 3, 3)
    @example([1, 2, 3, 4], 3, 1)
    def test_slice_list(self, x, y, z):
        source_code = &#34;&#34;&#34;
def validator(x: List[int], y: int, z: int) -&gt; List[int]:
    return x[y:z]
            &#34;&#34;&#34;
        try:
            exp = x[y:z]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y, z)
        except:
            ret = None
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in exp] if exp is not None else exp,
            &#34;list slice returned wrong value&#34;,
        )

    @given(x=st.lists(st.integers(), max_size=20), y=st.integers())
    @example([0], -2)
    @example([1, 2, 3, 4], 1)
    @example([1, 2, 3, 4], 2)
    @example([1, 2, 3, 4], 2)
    @example([1, 2, 3, 4], 3)
    @example([1, 2, 3, 4], 3)
    def test_slice_list_lower(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: List[int], y: int) -&gt; List[int]:
    return x[y:]
            &#34;&#34;&#34;
        try:
            exp = x[y:]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in exp] if exp is not None else exp,
            &#34;list slice returned wrong value&#34;,
        )

    @given(x=st.lists(st.integers(), max_size=20), y=st.integers())
    @example([0], 0)
    @example([1, 2, 3, 4], 2)
    @example([1, 2, 3, 4], 4)
    @example([1, 2, 3, 4], 2)
    @example([1, 2, 3, 4], 3)
    @example([1, 2, 3, 4], 1)
    def test_slice_list_upper(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: List[int], y: int) -&gt; List[int]:
    return x[:y]
            &#34;&#34;&#34;
        try:
            exp = x[:y]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x, y)
        except:
            ret = None
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in exp] if exp is not None else exp,
            &#34;list slice returned wrong value&#34;,
        )

    @given(x=st.lists(st.integers(), max_size=20))
    @example([0])
    @example([1, 2, 3, 4])
    @example([1, 2, 3, 4])
    @example([1, 2, 3, 4])
    @example([1, 2, 3, 4])
    @example([1, 2, 3, 4])
    def test_slice_list_full(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: List[int]) -&gt; List[int]:
    return x[:]
            &#34;&#34;&#34;
        try:
            exp = x[:]
        except IndexError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, x)
        except:
            ret = None
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in exp] if exp is not None else exp,
            &#34;list slice returned wrong value&#34;,
        )

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0, 1], y=-1)
    @example(xs=[0, 1], y=0)
    def test_in_list_int(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y in xs, &#34;list in returned wrong value&#34;)

    @given(xs=st.lists(st.binary()), y=st.binary())
    def test_in_list_bytes(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[bytes], y: bytes) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y in xs, &#34;list in returned wrong value&#34;)

    @given(xs=uplc_data_list, y=uplc_data)
    def test_in_list_data(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
from pycardano import Datum as Anything, PlutusData
def validator(x: List[Anything], y: Anything) -&gt; bool:
    return y in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y in xs.value, &#34;list in returned wrong value&#34;)

    @given(xs=uplc_data_list, y=uplc_data)
    def test_not_in_list_data(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
from pycardano import Datum as Anything, PlutusData
def validator(x: List[Anything], y: Anything) -&gt; bool:
    return y not in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y not in xs.value, &#34;list not in returned wrong value&#34;)

    @given(xs=st.lists(st.integers()), y=st.integers())
    @example(xs=[0, 1], y=-1)
    @example(xs=[0, 1], y=0)
    def test_not_in_list_int(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[int], y: int) -&gt; bool:
    return y not in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y not in xs, &#34;list not in returned wrong value&#34;)

    @given(xs=st.lists(st.binary()), y=st.binary())
    def test_not_in_list_bytes(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: List[bytes], y: bytes) -&gt; bool:
    return y not in x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, y)
        self.assertEqual(ret, y not in xs, &#34;list not in returned wrong value&#34;)

    @given(x=st.lists(st.integers()))
    def test_not_list(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: List[int]) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_eq_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;bytes eq returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_eq_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;int eq returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_eq_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y.encode(&#34;utf8&#34;))
        self.assertEqual(ret, x == y, &#34;str eq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_eq_bool(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;bool eq returned wrong value&#34;)

    @given(x=uplc_data, y=uplc_data)
    def test_eq_data(self, x, y):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Anything, y: Anything) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;any eq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.integers())
    def test_eq_bool_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: int) -&gt; bool:
    return x == y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x == y, &#34;bool eq int returned wrong value&#34;)

    @given(x=st.text(), y=st.text())
    def test_neq_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: str) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y.encode(&#34;utf8&#34;))
        self.assertEqual(ret, x != y, &#34;str neq returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_neq_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;int neq returned wrong value&#34;)

    @given(x=st.binary(), y=st.binary())
    def test_neq_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: bytes) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;bytes neq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.booleans())
    def test_neq_bool(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: bool) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;bool neq returned wrong value&#34;)

    @given(x=st.booleans(), y=st.integers())
    def test_neq_bool_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bool, y: int) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;bool neq int returned wrong value&#34;)

    @given(x=uplc_data, y=uplc_data)
    def test_neq_data(self, x, y):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Anything, y: Anything) -&gt; bool:
    return x != y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x != y, &#34;any neq returned wrong value&#34;)

    @given(x=st.integers(min_value=0, max_value=150), y=st.text())
    def test_mul_int_str(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: str) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y.encode(&#34;utf8&#34;))
        self.assertEqual(ret.decode(&#34;utf8&#34;), x * y, &#34;* returned wrong value&#34;)

    @given(x=st.text(), y=st.integers(min_value=0, max_value=150))
    def test_mul_str_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: str, y: int) -&gt; str:
    return x * y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y)
        self.assertEqual(ret.decode(&#34;utf8&#34;), x * y, &#34;* returned wrong value&#34;)

    @given(x=st.integers(min_value=0, max_value=150), y=st.binary())
    def test_mul_int_bytes(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: bytes) -&gt; bytes:
    return x * y
        &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x * y, &#34;bytes int multiplication returned wrong value&#34;)

    @given(x=st.binary(), y=st.integers(min_value=0, max_value=150))
    def test_mul_bytes_int(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: bytes, y: int) -&gt; bytes:
    return x * y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y)
        self.assertEqual(ret, x * y, &#34;* returned wrong value&#34;)

    @given(
        xs=st.lists(st.integers(), max_size=20), ys=st.lists(st.integers(), max_size=20)
    )
    def test_add_list(self, xs, ys):
        source_code = &#34;&#34;&#34;
def validator(x: List[int], y: List[int]) -&gt; List[int]:
    return x + y
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, xs, ys)
        self.assertEqual(
            ret,
            [PlutusInteger(x) for x in xs] + [PlutusInteger(y) for y in ys],
            &#34;+ returned wrong value&#34;,
        )

    @given(x=st.integers())
    def test_fmt_int(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: int) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(
            ret.decode(&#34;utf8&#34;), f&#34;{x}&#34;, &#34;int string formatting returned wrong value&#34;
        )

    @given(x=st.booleans())
    def test_fmt_bool(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bool) -&gt; str:
    return f&#34;{x}&#34;
    &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(
            ret.decode(&#34;utf8&#34;), f&#34;{x}&#34;, &#34;bool string formatting returned wrong value&#34;
        )

    @given(x=st.text())
    def test_fmt_str(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: str) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;))
        self.assertEqual(
            ret.decode(&#34;utf8&#34;), f&#34;{x}&#34;, &#34;string string formatting returned wrong value&#34;
        )

    @given(x=st.binary())
    @example(b&#34;&#39;&#34;)
    @example(b&#39;&#34;&#39;)
    @example(b&#34;\\&#34;)
    @example(b&#34;\r&#34;)
    @example(b&#34;\n&#34;)
    @example(b&#34;\t&#34;)
    @example(b&#34;\x7f&#34;)
    def test_fmt_bytes(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; str:
    return f&#34;{x}&#34;
        &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x).decode(&#34;utf8&#34;)
        if b&#34;&#39;&#34; not in x:
            self.assertEqual(
                ret, f&#34;{x}&#34;, &#34;bytes string formatting returned wrong value&#34;
            )
        else:
            # NOTE: formally this is a bug where we do not have the same semantics as python
            # specifically when &#39; is contained in the string we do not change the quotation marks
            self.assertEqual(
                eval(ret), x, &#34;bytes string formatting returned wrong value&#34;
            )

    @given(x=st.none())
    def test_fmt_none(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: None) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, Unit()).decode(&#34;utf8&#34;)
        self.assertEqual(ret, f&#34;{x}&#34;, &#34;none string formatting returned wrong value&#34;)

    @given(
        x=st.builds(
            UpperBoundPOSIXTime,
            st.one_of(
                st.builds(FinitePOSIXTime, st.integers()), st.builds(PosInfPOSIXTime)
            ),
            st.one_of(st.builds(TrueData), st.builds(FalseData)),
        )
    )
    @example(UpperBoundPOSIXTime(PosInfPOSIXTime(), TrueData()))
    def test_fmt_dataclass(self, x: UpperBoundPOSIXTime):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: UpperBoundPOSIXTime) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;

        ret = eval_uplc_value(source_code, x).decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, f&#34;{x}&#34;, &#34;several element string formatting returned wrong value&#34;
        )

    @given(x=st.integers(), y=st.integers())
    def test_fmt_multiple(self, x, y):
        source_code = &#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    return f&#34;a{x}b{y}c&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x, y).decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, f&#34;a{x}b{y}c&#34;, &#34;several element string formatting returned wrong value&#34;
        )

    @given(x=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_tuple_int(self, x):
        params = [f&#34;a{i}&#34; for i in range(len(x))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: int&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, *x if x else [0]).decode(&#34;utf8&#34;)
        exp = f&#34;{tuple(x)}&#34;
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )

    @given(xs=st.lists(formattable_text))
    def test_fmt_tuple_str(self, xs):
        # TODO strings are not properly escaped here
        params = [f&#34;a{i}&#34; for i in range(len(xs))]
        source_code = f&#34;&#34;&#34;
def validator({&#34;,&#34;.join(p + &#34;: str&#34; for p in params)}) -&gt; str:
    return f&#34;{{({&#34;&#34;.join(p + &#34;,&#34; for p in params)})}}&#34;
            &#34;&#34;&#34;
        ret = eval_uplc_value(
            source_code, *(x.encode(&#34;utf8&#34;) for x in xs) if xs else [0]
        ).decode(&#34;utf8&#34;)
        exp = f&#34;{tuple(xs)}&#34;
        self.assertEqual(ret, exp, &#34;tuple string formatting returned wrong value&#34;)

    @given(x=st.integers(), y=st.integers())
    def test_fmt_pair_int(self, x, y):
        source_code = f&#34;&#34;&#34;
def validator(x: int, y: int) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        exp = f&#34;{(x, y)}&#34;
        ret = eval_uplc_value(source_code, x, y).decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer tuple string formatting returned wrong value&#34;
        )

    @given(x=formattable_text, y=formattable_text)
    def test_fmt_pair_str(self, x, y):
        # TODO strings are not properly escaped here
        source_code = f&#34;&#34;&#34;
def validator(x: str, y: str) -&gt; str:
    a = &#34;&#34;
    for p in {{x:y}}.items():
        a = f&#34;{{p}}&#34;
    return a
            &#34;&#34;&#34;
        exp = f&#34;{(x, y)}&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;), y.encode(&#34;utf8&#34;)).decode(
            &#34;utf8&#34;
        )
        self.assertEqual(
            ret, exp, &#34;string tuple string formatting returned wrong value&#34;
        )

    @given(xs=st.lists(formattable_text))
    @example([])
    @example([&#34;x&#34;])
    def test_fmt_list_str(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[str]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        exp = f&#34;{list(xs)}&#34;
        ret = eval_uplc_value(source_code, [x.encode(&#34;utf8&#34;) for x in xs]).decode(
            &#34;utf8&#34;
        )
        self.assertEqual(ret, exp, &#34;string list string formatting returned wrong value&#34;)

    @given(xs=st.lists(st.integers()))
    @example([])
    @example([0])
    def test_fmt_list_int(self, xs):
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: List[int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        exp = f&#34;{list(xs)}&#34;
        ret = eval_uplc_value(source_code, xs).decode(&#34;utf8&#34;)
        self.assertEqual(
            ret, exp, &#34;integer list string formatting returned wrong value&#34;
        )

    @given(x=st.dictionaries(st.integers(), st.integers()))
    def test_not_dict(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: Dict[int, int]) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(xs=st.dictionaries(st.integers(), st.integers()), y=st.integers())
    def test_index_dict(self, xs, y):
        source_code = &#34;&#34;&#34;
from typing import Dict, List, Union
def validator(x: Dict[int, int], y: int) -&gt; int:
    return x[y]
            &#34;&#34;&#34;
        try:
            exp = xs[y]
        except KeyError:
            exp = None
        try:
            ret = eval_uplc_value(source_code, xs, y)
        except Exception as e:
            ret = None
        self.assertEqual(ret, exp, &#34;list index returned wrong value&#34;)

    @given(xs=st.dictionaries(formattable_text, st.integers()))
    @example(dict())
    @example({&#34;&#34;: 0})
    def test_fmt_dict_int(self, xs):
        # TODO strings are not properly escaped here
        source_code = &#34;&#34;&#34;
from opshin.prelude import *

def validator(x: Dict[str, int]) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        exp = f&#34;{dict(xs)}&#34;
        ret = eval_uplc_value(
            source_code, {k.encode(&#34;utf8&#34;): v for k, v in xs.items()}
        ).decode(&#34;utf8&#34;)
        self.assertEqual(ret, exp, &#34;dict string formatting returned wrong value&#34;)

    @given(x=uplc_data)
    @example(PlutusByteString(b&#34;&#34;))
    @example(PlutusConstr(0, [PlutusByteString(b&#34;&#39;&#34;)]))
    @example(
        PlutusMap({PlutusInteger(1): PlutusMap({}), PlutusInteger(0): PlutusMap({})})
    )
    def test_fmt_any(self, x):
        x_cbor = uplc.plutus_cbor_dumps(x)
        x_data = pycardano.RawPlutusData(cbor2.loads(x_cbor))
        source_code = &#34;&#34;&#34;
def validator(x: Anything) -&gt; str:
    return f&#34;{x}&#34;
            &#34;&#34;&#34;
        # NOTE: this is technically a deviation from the semantics of pycardano but I expect the pycardano semantics to change soon
        exp = f&#34;RawPlutusData(data={repr(x_data.data)})&#34;
        ret = eval_uplc_value(source_code, pycardano.RawCBOR(x_cbor)).decode(&#34;utf8&#34;)
        if &#34;\\&#39;&#34; in ret:
            RawPlutusData = pycardano.RawPlutusData
            CBORTag = cbor2.CBORTag
            self.assertEqual(
                eval(ret), x_data, &#34;raw cbor string formatting returned wrong value&#34;
            )
        else:
            self.assertEqual(
                ret, exp, &#34;raw cbor string formatting returned wrong value&#34;
            )

    @given(x=st.text())
    def test_not_string(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: str) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x.encode(&#34;utf8&#34;))
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    @given(x=st.binary())
    def test_not_bytes(self, x):
        source_code = &#34;&#34;&#34;
def validator(x: bytes) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, x)
        self.assertEqual(bool(ret), not x, &#34;not returned wrong value&#34;)

    def test_not_unit(self):
        source_code = &#34;&#34;&#34;
def validator(x: None) -&gt; bool:
    return not x
            &#34;&#34;&#34;
        ret = eval_uplc_value(source_code, uplc.BuiltinUnit())
        self.assertEqual(bool(ret), not None, &#34;not returned wrong value&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="opshin.tests.test_ops.OpTest.test_add_bytes"><code class="name flex">
<span>def <span class="ident">test_add_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_add_int"><code class="name flex">
<span>def <span class="ident">test_add_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_add_list"><code class="name flex">
<span>def <span class="ident">test_add_list</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_add_str"><code class="name flex">
<span>def <span class="ident">test_add_str</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_and_bool"><code class="name flex">
<span>def <span class="ident">test_and_bool</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_div_int"><code class="name flex">
<span>def <span class="ident">test_div_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_bool"><code class="name flex">
<span>def <span class="ident">test_eq_bool</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_bool_int"><code class="name flex">
<span>def <span class="ident">test_eq_bool_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_bytes"><code class="name flex">
<span>def <span class="ident">test_eq_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_data"><code class="name flex">
<span>def <span class="ident">test_eq_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_int"><code class="name flex">
<span>def <span class="ident">test_eq_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_eq_str"><code class="name flex">
<span>def <span class="ident">test_eq_str</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_any"><code class="name flex">
<span>def <span class="ident">test_fmt_any</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_bool"><code class="name flex">
<span>def <span class="ident">test_fmt_bool</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_bytes"><code class="name flex">
<span>def <span class="ident">test_fmt_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_dataclass"><code class="name flex">
<span>def <span class="ident">test_fmt_dataclass</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_dict_int"><code class="name flex">
<span>def <span class="ident">test_fmt_dict_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_int"><code class="name flex">
<span>def <span class="ident">test_fmt_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_list_int"><code class="name flex">
<span>def <span class="ident">test_fmt_list_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_list_str"><code class="name flex">
<span>def <span class="ident">test_fmt_list_str</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_multiple"><code class="name flex">
<span>def <span class="ident">test_fmt_multiple</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_none"><code class="name flex">
<span>def <span class="ident">test_fmt_none</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_pair_int"><code class="name flex">
<span>def <span class="ident">test_fmt_pair_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_pair_str"><code class="name flex">
<span>def <span class="ident">test_fmt_pair_str</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_str"><code class="name flex">
<span>def <span class="ident">test_fmt_str</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_tuple_int"><code class="name flex">
<span>def <span class="ident">test_fmt_tuple_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_fmt_tuple_str"><code class="name flex">
<span>def <span class="ident">test_fmt_tuple_str</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_in_list_bytes"><code class="name flex">
<span>def <span class="ident">test_in_list_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_in_list_data"><code class="name flex">
<span>def <span class="ident">test_in_list_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_in_list_int"><code class="name flex">
<span>def <span class="ident">test_in_list_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_index_bytes"><code class="name flex">
<span>def <span class="ident">test_index_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_index_dict"><code class="name flex">
<span>def <span class="ident">test_index_dict</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_index_list"><code class="name flex">
<span>def <span class="ident">test_index_list</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mod_int"><code class="name flex">
<span>def <span class="ident">test_mod_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_bytes_int"><code class="name flex">
<span>def <span class="ident">test_mul_bytes_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_int"><code class="name flex">
<span>def <span class="ident">test_mul_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_int_bytes"><code class="name flex">
<span>def <span class="ident">test_mul_int_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_int_str"><code class="name flex">
<span>def <span class="ident">test_mul_int_str</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_mul_str_int"><code class="name flex">
<span>def <span class="ident">test_mul_str_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_neg_pow_int"><code class="name flex">
<span>def <span class="ident">test_neg_pow_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_neq_bool"><code class="name flex">
<span>def <span class="ident">test_neq_bool</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_neq_bool_int"><code class="name flex">
<span>def <span class="ident">test_neq_bool_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_neq_bytes"><code class="name flex">
<span>def <span class="ident">test_neq_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_neq_data"><code class="name flex">
<span>def <span class="ident">test_neq_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_neq_int"><code class="name flex">
<span>def <span class="ident">test_neq_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_neq_str"><code class="name flex">
<span>def <span class="ident">test_neq_str</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_bool"><code class="name flex">
<span>def <span class="ident">test_not_bool</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_bytes"><code class="name flex">
<span>def <span class="ident">test_not_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_dict"><code class="name flex">
<span>def <span class="ident">test_not_dict</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_in_list_bytes"><code class="name flex">
<span>def <span class="ident">test_not_in_list_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_in_list_data"><code class="name flex">
<span>def <span class="ident">test_not_in_list_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_in_list_int"><code class="name flex">
<span>def <span class="ident">test_not_in_list_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_int"><code class="name flex">
<span>def <span class="ident">test_not_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_list"><code class="name flex">
<span>def <span class="ident">test_not_list</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_string"><code class="name flex">
<span>def <span class="ident">test_not_string</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_not_unit"><code class="name flex">
<span>def <span class="ident">test_not_unit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_or_bool"><code class="name flex">
<span>def <span class="ident">test_or_bool</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_pow_int"><code class="name flex">
<span>def <span class="ident">test_pow_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_bytes"><code class="name flex">
<span>def <span class="ident">test_slice_bytes</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_bytes_full"><code class="name flex">
<span>def <span class="ident">test_slice_bytes_full</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_bytes_lower"><code class="name flex">
<span>def <span class="ident">test_slice_bytes_lower</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_bytes_upper"><code class="name flex">
<span>def <span class="ident">test_slice_bytes_upper</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_list"><code class="name flex">
<span>def <span class="ident">test_slice_list</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_list_full"><code class="name flex">
<span>def <span class="ident">test_slice_list_full</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_list_lower"><code class="name flex">
<span>def <span class="ident">test_slice_list_lower</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_slice_list_upper"><code class="name flex">
<span>def <span class="ident">test_slice_list_upper</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_sub_int"><code class="name flex">
<span>def <span class="ident">test_sub_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_uadd_int"><code class="name flex">
<span>def <span class="ident">test_uadd_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="opshin.tests.test_ops.OpTest.test_usub_int"><code class="name flex">
<span>def <span class="ident">test_usub_int</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="max-width: 330px; margin-bottom: 10px">
<header>
<a class="homelink" rel="home" title="opshin Home" href="https://opshin.opshin.dev/">
<img src="https://raw.githubusercontent.com/OpShin/opshin/master/opshin.png" alt="opshin logo"> &nbsp; opshin
</a>
</header>
</div>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opshin.tests" href="index.html">opshin.tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="opshin.tests.test_ops.frozenlist" href="#opshin.tests.test_ops.frozenlist">frozenlist</a></code></li>
<li><code><a title="opshin.tests.test_ops.rec_data_strategies" href="#opshin.tests.test_ops.rec_data_strategies">rec_data_strategies</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="opshin.tests.test_ops.OpTest" href="#opshin.tests.test_ops.OpTest">OpTest</a></code></h4>
<ul class="">
<li><code><a title="opshin.tests.test_ops.OpTest.test_add_bytes" href="#opshin.tests.test_ops.OpTest.test_add_bytes">test_add_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_add_int" href="#opshin.tests.test_ops.OpTest.test_add_int">test_add_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_add_list" href="#opshin.tests.test_ops.OpTest.test_add_list">test_add_list</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_add_str" href="#opshin.tests.test_ops.OpTest.test_add_str">test_add_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_and_bool" href="#opshin.tests.test_ops.OpTest.test_and_bool">test_and_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_div_int" href="#opshin.tests.test_ops.OpTest.test_div_int">test_div_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_bool" href="#opshin.tests.test_ops.OpTest.test_eq_bool">test_eq_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_bool_int" href="#opshin.tests.test_ops.OpTest.test_eq_bool_int">test_eq_bool_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_bytes" href="#opshin.tests.test_ops.OpTest.test_eq_bytes">test_eq_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_data" href="#opshin.tests.test_ops.OpTest.test_eq_data">test_eq_data</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_int" href="#opshin.tests.test_ops.OpTest.test_eq_int">test_eq_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_eq_str" href="#opshin.tests.test_ops.OpTest.test_eq_str">test_eq_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_any" href="#opshin.tests.test_ops.OpTest.test_fmt_any">test_fmt_any</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_bool" href="#opshin.tests.test_ops.OpTest.test_fmt_bool">test_fmt_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_bytes" href="#opshin.tests.test_ops.OpTest.test_fmt_bytes">test_fmt_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_dataclass" href="#opshin.tests.test_ops.OpTest.test_fmt_dataclass">test_fmt_dataclass</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_dict_int" href="#opshin.tests.test_ops.OpTest.test_fmt_dict_int">test_fmt_dict_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_int" href="#opshin.tests.test_ops.OpTest.test_fmt_int">test_fmt_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_list_int" href="#opshin.tests.test_ops.OpTest.test_fmt_list_int">test_fmt_list_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_list_str" href="#opshin.tests.test_ops.OpTest.test_fmt_list_str">test_fmt_list_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_multiple" href="#opshin.tests.test_ops.OpTest.test_fmt_multiple">test_fmt_multiple</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_none" href="#opshin.tests.test_ops.OpTest.test_fmt_none">test_fmt_none</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_pair_int" href="#opshin.tests.test_ops.OpTest.test_fmt_pair_int">test_fmt_pair_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_pair_str" href="#opshin.tests.test_ops.OpTest.test_fmt_pair_str">test_fmt_pair_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_str" href="#opshin.tests.test_ops.OpTest.test_fmt_str">test_fmt_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_tuple_int" href="#opshin.tests.test_ops.OpTest.test_fmt_tuple_int">test_fmt_tuple_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_fmt_tuple_str" href="#opshin.tests.test_ops.OpTest.test_fmt_tuple_str">test_fmt_tuple_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_in_list_bytes" href="#opshin.tests.test_ops.OpTest.test_in_list_bytes">test_in_list_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_in_list_data" href="#opshin.tests.test_ops.OpTest.test_in_list_data">test_in_list_data</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_in_list_int" href="#opshin.tests.test_ops.OpTest.test_in_list_int">test_in_list_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_index_bytes" href="#opshin.tests.test_ops.OpTest.test_index_bytes">test_index_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_index_dict" href="#opshin.tests.test_ops.OpTest.test_index_dict">test_index_dict</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_index_list" href="#opshin.tests.test_ops.OpTest.test_index_list">test_index_list</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mod_int" href="#opshin.tests.test_ops.OpTest.test_mod_int">test_mod_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_bytes_int" href="#opshin.tests.test_ops.OpTest.test_mul_bytes_int">test_mul_bytes_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_int" href="#opshin.tests.test_ops.OpTest.test_mul_int">test_mul_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_int_bytes" href="#opshin.tests.test_ops.OpTest.test_mul_int_bytes">test_mul_int_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_int_str" href="#opshin.tests.test_ops.OpTest.test_mul_int_str">test_mul_int_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_mul_str_int" href="#opshin.tests.test_ops.OpTest.test_mul_str_int">test_mul_str_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_neg_pow_int" href="#opshin.tests.test_ops.OpTest.test_neg_pow_int">test_neg_pow_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_neq_bool" href="#opshin.tests.test_ops.OpTest.test_neq_bool">test_neq_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_neq_bool_int" href="#opshin.tests.test_ops.OpTest.test_neq_bool_int">test_neq_bool_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_neq_bytes" href="#opshin.tests.test_ops.OpTest.test_neq_bytes">test_neq_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_neq_data" href="#opshin.tests.test_ops.OpTest.test_neq_data">test_neq_data</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_neq_int" href="#opshin.tests.test_ops.OpTest.test_neq_int">test_neq_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_neq_str" href="#opshin.tests.test_ops.OpTest.test_neq_str">test_neq_str</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_bool" href="#opshin.tests.test_ops.OpTest.test_not_bool">test_not_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_bytes" href="#opshin.tests.test_ops.OpTest.test_not_bytes">test_not_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_dict" href="#opshin.tests.test_ops.OpTest.test_not_dict">test_not_dict</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_in_list_bytes" href="#opshin.tests.test_ops.OpTest.test_not_in_list_bytes">test_not_in_list_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_in_list_data" href="#opshin.tests.test_ops.OpTest.test_not_in_list_data">test_not_in_list_data</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_in_list_int" href="#opshin.tests.test_ops.OpTest.test_not_in_list_int">test_not_in_list_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_int" href="#opshin.tests.test_ops.OpTest.test_not_int">test_not_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_list" href="#opshin.tests.test_ops.OpTest.test_not_list">test_not_list</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_string" href="#opshin.tests.test_ops.OpTest.test_not_string">test_not_string</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_not_unit" href="#opshin.tests.test_ops.OpTest.test_not_unit">test_not_unit</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_or_bool" href="#opshin.tests.test_ops.OpTest.test_or_bool">test_or_bool</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_pow_int" href="#opshin.tests.test_ops.OpTest.test_pow_int">test_pow_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_bytes" href="#opshin.tests.test_ops.OpTest.test_slice_bytes">test_slice_bytes</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_bytes_full" href="#opshin.tests.test_ops.OpTest.test_slice_bytes_full">test_slice_bytes_full</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_bytes_lower" href="#opshin.tests.test_ops.OpTest.test_slice_bytes_lower">test_slice_bytes_lower</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_bytes_upper" href="#opshin.tests.test_ops.OpTest.test_slice_bytes_upper">test_slice_bytes_upper</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_list" href="#opshin.tests.test_ops.OpTest.test_slice_list">test_slice_list</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_list_full" href="#opshin.tests.test_ops.OpTest.test_slice_list_full">test_slice_list_full</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_list_lower" href="#opshin.tests.test_ops.OpTest.test_slice_list_lower">test_slice_list_lower</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_slice_list_upper" href="#opshin.tests.test_ops.OpTest.test_slice_list_upper">test_slice_list_upper</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_sub_int" href="#opshin.tests.test_ops.OpTest.test_sub_int">test_sub_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_uadd_int" href="#opshin.tests.test_ops.OpTest.test_uadd_int">test_uadd_int</a></code></li>
<li><code><a title="opshin.tests.test_ops.OpTest.test_usub_int" href="#opshin.tests.test_ops.OpTest.test_usub_int">test_usub_int</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
